!function (global) { var LiteGraph = global.LiteGraph = { VERSION: .4, CANVAS_GRID_SIZE: 10, NODE_TITLE_HEIGHT: 30, NODE_TITLE_TEXT_Y: 20, NODE_SLOT_HEIGHT: 20, NODE_WIDGET_HEIGHT: 20, NODE_WIDTH: 140, NODE_MIN_WIDTH: 50, NODE_COLLAPSED_RADIUS: 10, NODE_COLLAPSED_WIDTH: 80, NODE_TITLE_COLOR: "#999", NODE_SELECTED_TITLE_COLOR: "#FFF", NODE_TEXT_SIZE: 14, NODE_TEXT_COLOR: "#AAA", NODE_SUBTEXT_SIZE: 12, NODE_DEFAULT_COLOR: "#333", NODE_DEFAULT_BGCOLOR: "#353535", NODE_DEFAULT_BOXCOLOR: "#666", NODE_DEFAULT_SHAPE: "box", NODE_BOX_OUTLINE_COLOR: "#FFF", DEFAULT_SHADOW_COLOR: "rgba(0,0,0,0.5)", DEFAULT_GROUP_FONT: 24, WIDGET_BGCOLOR: "#222", WIDGET_OUTLINE_COLOR: "#666", WIDGET_TEXT_COLOR: "#DDD", WIDGET_SECONDARY_TEXT_COLOR: "#999", LINK_COLOR: "#9A9", EVENT_LINK_COLOR: "#A86", CONNECTING_LINK_COLOR: "#AFA", MAX_NUMBER_OF_NODES: 1e3, DEFAULT_POSITION: [100, 100], VALID_SHAPES: ["default", "box", "round", "card"], BOX_SHAPE: 1, ROUND_SHAPE: 2, CIRCLE_SHAPE: 3, CARD_SHAPE: 4, ARROW_SHAPE: 5, GRID_SHAPE: 6, INPUT: 1, OUTPUT: 2, EVENT: -1, ACTION: -1, NODE_MODES: ["Always", "On Event", "Never", "On Trigger"], NODE_MODES_COLORS: ["#666", "#422", "#333", "#224", "#626"], ALWAYS: 0, ON_EVENT: 1, NEVER: 2, ON_TRIGGER: 3, UP: 1, DOWN: 2, LEFT: 3, RIGHT: 4, CENTER: 5, LINK_RENDER_MODES: ["Straight", "Linear", "Spline"], STRAIGHT_LINK: 0, LINEAR_LINK: 1, SPLINE_LINK: 2, NORMAL_TITLE: 0, NO_TITLE: 1, TRANSPARENT_TITLE: 2, AUTOHIDE_TITLE: 3, VERTICAL_LAYOUT: "vertical", proxy: null, node_images_path: "", debug: !1, catch_exceptions: !0, throw_errors: !0, allow_scripts: !1, use_deferred_actions: !0, registered_node_types: {}, node_types_by_file_extension: {}, Nodes: {}, Globals: {}, searchbox_extras: {}, auto_sort_node_types: !1, node_box_coloured_when_on: !1, node_box_coloured_by_mode: !1, dialog_close_on_mouse_leave: !0, dialog_close_on_mouse_leave_delay: 500, shift_click_do_break_link_from: !1, click_do_break_link_to: !1, search_hide_on_mouse_leave: !0, search_filter_enabled: !1, search_show_all_on_open: !0, auto_load_slot_types: !1, registered_slot_in_types: {}, registered_slot_out_types: {}, slot_types_in: [], slot_types_out: [], slot_types_default_in: [], slot_types_default_out: [], alt_drag_do_clone_nodes: !1, do_add_triggers_slots: !1, allow_multi_output_for_events: !0, middle_click_slot_add_default_node: !1, release_link_on_empty_shows_menu: !1, pointerevents_method: "mouse", ctrl_shift_v_paste_connect_unselected_outputs: !1, use_uuids: !1, registerNodeType: function (t, e) { if (!e.prototype) throw "Cannot register a simple object, it must be a class with a prototype"; e.type = t, LiteGraph.debug && console.log("Node registered: " + t); let n = e.name, i = t.lastIndexOf("/"); for (var o in e.category = t.substring(0, i), e.title || (e.title = n), LGraphNode.prototype) e.prototype[o] || (e.prototype[o] = LGraphNode.prototype[o]); let s = this.registered_node_types[t]; if (s && console.log("replacing node type: " + t), !Object.prototype.hasOwnProperty.call(e.prototype, "shape") && (Object.defineProperty(e.prototype, "shape", { set: function (t) { switch (t) { case "default": delete this._shape; break; case "box": this._shape = LiteGraph.BOX_SHAPE; break; case "round": this._shape = LiteGraph.ROUND_SHAPE; break; case "circle": this._shape = LiteGraph.CIRCLE_SHAPE; break; case "card": this._shape = LiteGraph.CARD_SHAPE; break; default: this._shape = t } }, get: function () { return this._shape }, enumerable: !0, configurable: !0 }), e.supported_extensions)) for (let r in e.supported_extensions) { let a = e.supported_extensions[r]; a && a.constructor === String && (this.node_types_by_file_extension[a.toLowerCase()] = e) } this.registered_node_types[t] = e, e.constructor.name && (this.Nodes[n] = e), LiteGraph.onNodeTypeRegistered && LiteGraph.onNodeTypeRegistered(t, e), s && LiteGraph.onNodeTypeReplaced && LiteGraph.onNodeTypeReplaced(t, e, s), e.prototype.onPropertyChange && console.warn("LiteGraph node class " + t + " has onPropertyChange method, it must be called onPropertyChanged with d at the end"), this.auto_load_slot_types && new e(e.title || "tmpnode") }, unregisterNodeType: function (t) { let e = t.constructor === String ? this.registered_node_types[t] : t; if (!e) throw "node type not found: " + t; delete this.registered_node_types[e.type], e.constructor.name && delete this.Nodes[e.constructor.name] }, registerNodeAndSlotType: function (t, e, n) { n = n || !1; let i = t.constructor === String && "anonymous" !== this.registered_node_types[t] ? this.registered_node_types[t] : t, o = i.constructor.type, s = []; s = "string" == typeof e ? e.split(",") : e == this.EVENT || e == this.ACTION ? ["_event_"] : ["*"]; for (let r = 0; r < s.length; ++r) { let a = s[r]; "" === a && (a = "*"); let l = n ? "registered_slot_out_types" : "registered_slot_in_types"; void 0 === this[l][a] && (this[l][a] = { nodes: [] }), this[l][a].nodes.includes(o) || this[l][a].nodes.push(o), n ? this.slot_types_out.includes(a.toLowerCase()) || (this.slot_types_out.push(a.toLowerCase()), this.slot_types_out.sort()) : this.slot_types_in.includes(a.toLowerCase()) || (this.slot_types_in.push(a.toLowerCase()), this.slot_types_in.sort()) } }, buildNodeClassFromObject: function (t, e) { var n = ""; if (e.inputs) for (var i = 0; i < e.inputs.length; ++i) { var o = e.inputs[i][0], s = e.inputs[i][1]; s && s.constructor === String && (s = '"' + s + '"'), n += "this.addInput('" + o + "'," + s + ");\n" } if (e.outputs) for (var i = 0; i < e.outputs.length; ++i) { var o = e.outputs[i][0], s = e.outputs[i][1]; s && s.constructor === String && (s = '"' + s + '"'), n += "this.addOutput('" + o + "'," + s + ");\n" } if (e.properties) for (var i in e.properties) { var r = e.properties[i]; r && r.constructor === String && (r = '"' + r + '"'), n += "this.addProperty('" + i + "'," + r + ");\n" } var a = Function(n += "if(this.onCreate)this.onCreate()"); for (var i in e) "inputs" != i && "outputs" != i && "properties" != i && (a.prototype[i] = e[i]); return a.title = e.title || t.split("/").pop(), a.desc = e.desc || "Generated from object", this.registerNodeType(t, a), a }, wrapFunctionAsNode: function (t, e, n, i, o) { var s = Array(e.length), r = ""; if (null !== n) for (var a = LiteGraph.getParameterNames(e), l = 0; l < a.length; ++l) { var h = 0; n && (null != n[l] && n[l].constructor === String ? h = "'" + n[l] + "'" : null != n[l] && (h = n[l])), r += "this.addInput('" + a[l] + "'," + h + ");\n" } null !== i && (r += "this.addOutput('out'," + (null != i ? i.constructor === String ? "'" + i + "'" : i : 0) + ");\n"), o && (r += "this.properties = " + JSON.stringify(o) + ";\n"); var u = Function(r); return u.title = t.split("/").pop(), u.desc = "Generated from " + e.name, u.prototype.onExecute = function t() { for (var n = 0; n < s.length; ++n)s[n] = this.getInputData(n); var i = e.apply(this, s); this.setOutputData(0, i) }, this.registerNodeType(t, u), u }, clearRegisteredTypes: function () { this.registered_node_types = {}, this.node_types_by_file_extension = {}, this.Nodes = {}, this.searchbox_extras = {} }, addNodeMethod: function (t, e) { for (var n in LGraphNode.prototype[t] = e, this.registered_node_types) { var i = this.registered_node_types[n]; i.prototype[t] && (i.prototype["_" + t] = i.prototype[t]), i.prototype[t] = e } }, createNode: function (t, e, n) { var i = this.registered_node_types[t]; if (!i) return LiteGraph.debug && console.log('GraphNode type "' + t + '" not registered.'), null; i.prototype, e = e || i.title || t; var o = null; if (LiteGraph.catch_exceptions) try { o = new i(e) } catch (s) { return console.error(s), null } else o = new i(e); if (o.type = t, !o.title && e && (o.title = e), o.properties || (o.properties = {}), o.properties_info || (o.properties_info = []), o.flags || (o.flags = {}), o.size || (o.size = o.computeSize()), o.pos || (o.pos = LiteGraph.DEFAULT_POSITION.concat()), o.mode || (o.mode = LiteGraph.ALWAYS), n) for (var r in n) o[r] = n[r]; return o.onNodeCreated && o.onNodeCreated(), o }, getNodeType: function (t) { return this.registered_node_types[t] }, getNodeTypesInCategory: function (t, e) { var n = []; for (var i in this.registered_node_types) { var o = this.registered_node_types[i]; o.filter == e && ("" == t ? null == o.category && n.push(o) : o.category == t && n.push(o)) } return this.auto_sort_node_types && n.sort(function (t, e) { return t.title.localeCompare(e.title) }), n }, getNodeTypesCategories: function (t) { var e = { "": 1 }; for (var n in this.registered_node_types) { var i = this.registered_node_types[n]; if (i.category && !i.skip_list) { if (i.filter != t) continue; e[i.category] = 1 } } var o = []; for (var n in e) o.push(n); return this.auto_sort_node_types ? o.sort() : o }, reloadNodes: function (t) { for (var e = document.getElementsByTagName("script"), n = [], i = 0; i < e.length; i++)n.push(e[i]); var o = document.getElementsByTagName("head")[0]; t = document.location.href + t; for (var i = 0; i < n.length; i++) { var s = n[i].src; if (s && s.substr(0, t.length) == t) try { LiteGraph.debug && console.log("Reloading: " + s); var r = document.createElement("script"); r.type = "text/javascript", r.src = s, o.appendChild(r), o.removeChild(n[i]) } catch (a) { if (LiteGraph.throw_errors) throw a; LiteGraph.debug && console.log("Error while reloading " + s) } } LiteGraph.debug && console.log("Nodes reloaded") }, cloneObject: function (t, e) { if (null == t) return null; var n = JSON.parse(JSON.stringify(t)); if (!e) return n; for (var i in n) e[i] = n[i]; return e }, uuidv4: function () { return "10000000-1000-4000-8000-100000000000".replace(/[018]/g, t => (t ^ 16 * Math.random() >> t / 4).toString(16)) }, isValidConnection: function (t, e) { if (("" == t || "*" === t) && (t = 0), ("" == e || "*" === e) && (e = 0), !t || !e || t == e || t == LiteGraph.EVENT && e == LiteGraph.ACTION) return !0; if (t = String(t), e = String(e), t = t.toLowerCase(), e = e.toLowerCase(), -1 == t.indexOf(",") && -1 == e.indexOf(",")) return t == e; for (var n = t.split(","), i = e.split(","), o = 0; o < n.length; ++o)for (var s = 0; s < i.length; ++s)if (this.isValidConnection(n[o], i[s])) return !0; return !1 }, registerSearchboxExtra: function (t, e, n) { this.searchbox_extras[e.toLowerCase()] = { type: t, desc: e, data: n } }, fetchFile: function (t, e, n, i) { if (!t) return null; if (e = e || "text", t.constructor === String) return "http" == t.substr(0, 4) && LiteGraph.proxy && (t = LiteGraph.proxy + t.substr(t.indexOf(":") + 3)), fetch(t).then(function (t) { if (!t.ok) throw Error("File not found"); return "arraybuffer" == e ? t.arrayBuffer() : "text" == e || "string" == e ? t.text() : "json" == e ? t.json() : "blob" == e ? t.blob() : void 0 }).then(function (t) { n && n(t) }).catch(function (e) { console.error("error fetching file:", t), i && i(e) }); if (t.constructor === File || t.constructor === Blob) { var o = new FileReader; if (o.onload = function (t) { var i = t.target.result; "json" == e && (i = JSON.parse(i)), n && n(i) }, "arraybuffer" == e) return o.readAsArrayBuffer(t); if ("text" == e || "json" == e) return o.readAsText(t); if ("blob" == e) return o.readAsBinaryString(t) } return null } }; function LGraph(t) { LiteGraph.debug && console.log("Graph created"), this.list_of_graphcanvas = null, this.clear(), t && this.configure(t) } function LLink(t, e, n, i, o, s) { this.id = t, this.type = e, this.origin_id = n, this.origin_slot = i, this.target_id = o, this.target_slot = s, this._data = null, this._pos = new Float32Array(2) } function LGraphNode(t) { this._ctor(t) } function LGraphGroup(t) { this._ctor(t) } function DragAndScale(t, e) { this.offset = new Float32Array([0, 0]), this.scale = 1, this.max_scale = 10, this.min_scale = .1, this.onredraw = null, this.enabled = !0, this.last_mouse = [0, 0], this.element = null, this.visible_area = new Float32Array(4), t && (this.element = t, e || this.bindEvents(t)) } function LGraphCanvas(t, e, n) { this.options = n = n || {}, this.background_image = LGraphCanvas.DEFAULT_BACKGROUND_IMAGE, t && t.constructor === String && (t = document.querySelector(t)), this.ds = new DragAndScale, this.zoom_modify_alpha = !0, this.title_text_font = "" + LiteGraph.NODE_TEXT_SIZE + "px Arial", this.inner_text_font = "normal " + LiteGraph.NODE_SUBTEXT_SIZE + "px Arial", this.node_title_color = LiteGraph.NODE_TITLE_COLOR, this.default_link_color = LiteGraph.LINK_COLOR, this.default_connection_color = { input_off: "#778", input_on: "#7F7", output_off: "#778", output_on: "#7F7" }, this.default_connection_color_byType = {}, this.default_connection_color_byTypeOff = {}, this.highquality_render = !0, this.use_gradients = !1, this.editor_alpha = 1, this.pause_rendering = !1, this.clear_background = !0, this.clear_background_color = "#222", this.read_only = !1, this.render_only_selected = !0, this.live_mode = !1, this.show_info = !0, this.allow_dragcanvas = !0, this.allow_dragnodes = !0, this.allow_interaction = !0, this.multi_select = !1, this.allow_searchbox = !0, this.allow_reconnect_links = !0, this.align_to_grid = !1, this.drag_mode = !1, this.dragging_rectangle = null, this.filter = null, this.set_canvas_dirty_on_mouse_event = !0, this.always_render_background = !1, this.render_shadows = !0, this.render_canvas_border = !0, this.render_connections_shadows = !1, this.render_connections_border = !0, this.render_curved_connections = !1, this.render_connection_arrows = !1, this.render_collapsed_slots = !0, this.render_execution_order = !1, this.render_title_colored = !0, this.render_link_tooltip = !0, this.links_render_mode = LiteGraph.SPLINE_LINK, this.mouse = [0, 0], this.graph_mouse = [0, 0], this.canvas_mouse = this.graph_mouse, this.onSearchBox = null, this.onSearchBoxSelection = null, this.onMouse = null, this.onDrawBackground = null, this.onDrawForeground = null, this.onDrawOverlay = null, this.onDrawLinkTooltip = null, this.onNodeMoved = null, this.onSelectionChange = null, this.onConnectingChange = null, this.onBeforeChange = null, this.onAfterChange = null, this.connections_width = 3, this.round_radius = 8, this.current_node = null, this.node_widget = null, this.over_link_center = null, this.last_mouse_position = [0, 0], this.visible_area = this.ds.visible_area, this.visible_links = [], this.viewport = n.viewport || null, e && e.attachCanvas(this), this.setCanvas(t, n.skip_events), this.clear(), n.skip_render || this.startRendering(), this.autoresize = n.autoresize } "undefined" != typeof performance ? LiteGraph.getTime = performance.now.bind(performance) : "undefined" != typeof Date && Date.now ? LiteGraph.getTime = Date.now.bind(Date) : "undefined" != typeof process ? LiteGraph.getTime = function () { var t = process.hrtime(); return .001 * t[0] + 1e-6 * t[1] } : LiteGraph.getTime = function t() { return new Date().getTime() }, global.LGraph = LiteGraph.LGraph = LGraph, LGraph.supported_types = ["number", "string", "boolean"], LGraph.prototype.getSupportedTypes = function () { return this.supported_types || LGraph.supported_types }, LGraph.STATUS_STOPPED = 1, LGraph.STATUS_RUNNING = 2, LGraph.prototype.clear = function () { if (this.stop(), this.status = LGraph.STATUS_STOPPED, this.last_node_id = 0, this.last_link_id = 0, this._version = -1, this._nodes) for (var t = 0; t < this._nodes.length; ++t) { var e = this._nodes[t]; e.onRemoved && e.onRemoved() } this._nodes = [], this._nodes_by_id = {}, this._nodes_in_order = [], this._nodes_executable = null, this._groups = [], this.links = {}, this.iteration = 0, this.config = {}, this.vars = {}, this.extra = {}, this.globaltime = 0, this.runningtime = 0, this.fixedtime = 0, this.fixedtime_lapse = .01, this.elapsed_time = .01, this.last_update_time = 0, this.starttime = 0, this.catch_errors = !0, this.nodes_executing = [], this.nodes_actioning = [], this.nodes_executedAction = [], this.inputs = {}, this.outputs = {}, this.change(), this.sendActionToCanvas("clear") }, LGraph.prototype.attachCanvas = function (t) { if (t.constructor != LGraphCanvas) throw "attachCanvas expects a LGraphCanvas instance"; t.graph && t.graph != this && t.graph.detachCanvas(t), t.graph = this, this.list_of_graphcanvas || (this.list_of_graphcanvas = []), this.list_of_graphcanvas.push(t) }, LGraph.prototype.detachCanvas = function (t) { if (this.list_of_graphcanvas) { var e = this.list_of_graphcanvas.indexOf(t); -1 != e && (t.graph = null, this.list_of_graphcanvas.splice(e, 1)) } }, LGraph.prototype.start = function (t) { if (this.status != LGraph.STATUS_RUNNING) { this.status = LGraph.STATUS_RUNNING, this.onPlayEvent && this.onPlayEvent(), this.sendEventToAllNodes("onStart"), this.starttime = LiteGraph.getTime(), this.last_update_time = this.starttime; var e = this; if (0 == (t = t || 0) && "undefined" != typeof window && window.requestAnimationFrame) { function n() { -1 == e.execution_timer_id && (window.requestAnimationFrame(n), e.onBeforeStep && e.onBeforeStep(), e.runStep(1, !e.catch_errors), e.onAfterStep && e.onAfterStep()) } this.execution_timer_id = -1, n() } else this.execution_timer_id = setInterval(function () { e.onBeforeStep && e.onBeforeStep(), e.runStep(1, !e.catch_errors), e.onAfterStep && e.onAfterStep() }, t) } }, LGraph.prototype.stop = function () { this.status != LGraph.STATUS_STOPPED && (this.status = LGraph.STATUS_STOPPED, this.onStopEvent && this.onStopEvent(), null != this.execution_timer_id && (-1 != this.execution_timer_id && clearInterval(this.execution_timer_id), this.execution_timer_id = null), this.sendEventToAllNodes("onStop")) }, LGraph.prototype.runStep = function (t, e, n) { t = t || 1; var i = LiteGraph.getTime(); this.globaltime = .001 * (i - this.starttime); var o = this._nodes_executable ? this._nodes_executable : this._nodes; if (o) { if (n = n || o.length, e) { for (var s = 0; s < t; s++) { for (var r = 0; r < n; ++r) { var a = o[r]; LiteGraph.use_deferred_actions && a._waiting_actions && a._waiting_actions.length && a.executePendingActions(), a.mode == LiteGraph.ALWAYS && a.onExecute && a.doExecute() } this.fixedtime += this.fixedtime_lapse, this.onExecuteStep && this.onExecuteStep() } this.onAfterExecute && this.onAfterExecute() } else try { for (var s = 0; s < t; s++) { for (var r = 0; r < n; ++r) { var a = o[r]; LiteGraph.use_deferred_actions && a._waiting_actions && a._waiting_actions.length && a.executePendingActions(), a.mode == LiteGraph.ALWAYS && a.onExecute && a.onExecute() } this.fixedtime += this.fixedtime_lapse, this.onExecuteStep && this.onExecuteStep() } this.onAfterExecute && this.onAfterExecute(), this.errors_in_execution = !1 } catch (l) { if (this.errors_in_execution = !0, LiteGraph.throw_errors) throw l; LiteGraph.debug && console.log("Error during execution: " + l), this.stop() } var h = LiteGraph.getTime(), u = h - i; 0 == u && (u = 1), this.execution_time = .001 * u, this.globaltime += .001 * u, this.iteration += 1, this.elapsed_time = (h - this.last_update_time) * .001, this.last_update_time = h, this.nodes_executing = [], this.nodes_actioning = [], this.nodes_executedAction = [] } }, LGraph.prototype.updateExecutionOrder = function () { this._nodes_in_order = this.computeExecutionOrder(!1), this._nodes_executable = []; for (var t = 0; t < this._nodes_in_order.length; ++t)this._nodes_in_order[t].onExecute && this._nodes_executable.push(this._nodes_in_order[t]) }, LGraph.prototype.computeExecutionOrder = function (t, e) { for (var n = [], i = [], o = {}, s = {}, r = {}, a = 0, l = this._nodes.length; a < l; ++a) { var h = this._nodes[a]; if (!t || h.onExecute) { o[h.id] = h; var u = 0; if (h.inputs) for (var p = 0, c = h.inputs.length; p < c; p++)h.inputs[p] && null != h.inputs[p].link && (u += 1); 0 == u ? (i.push(h), e && (h._level = 1)) : (e && (h._level = 0), r[h.id] = u) } } for (; 0 != i.length;) { var h = i.shift(); if (n.push(h), delete o[h.id], h.outputs) for (var a = 0; a < h.outputs.length; a++) { var d = h.outputs[a]; if (null != d && null != d.links && 0 != d.links.length) for (var p = 0; p < d.links.length; p++) { var g = d.links[p], f = this.links[g]; if (f && !s[f.id]) { var v = this.getNodeById(f.target_id); if (null == v) { s[f.id] = !0; continue } e && (!v._level || v._level <= h._level) && (v._level = h._level + 1), s[f.id] = !0, r[v.id] -= 1, 0 == r[v.id] && i.push(v) } } } } for (var a in o) n.push(o[a]); n.length != this._nodes.length && LiteGraph.debug && console.warn("something went wrong, nodes missing"); for (var l = n.length, a = 0; a < l; ++a)n[a].order = a; n = n.sort(function (t, e) { var n = t.constructor.priority || t.priority || 0, i = e.constructor.priority || e.priority || 0; return n == i ? t.order - e.order : n - i }); for (var a = 0; a < l; ++a)n[a].order = a; return n }, LGraph.prototype.getAncestors = function (t) { for (var e = [], n = [t], i = {}; n.length;) { var o = n.shift(); if (o.inputs) { i[o.id] || o == t || (i[o.id] = !0, e.push(o)); for (var s = 0; s < o.inputs.length; ++s) { var r = o.getInputNode(s); r && -1 == e.indexOf(r) && n.push(r) } } } return e.sort(function (t, e) { return t.order - e.order }), e }, LGraph.prototype.arrange = function (t, e) { t = t || 100; let n = this.computeExecutionOrder(!1, !0), i = []; for (let o = 0; o < n.length; ++o) { let s = n[o], r = s._level || 1; i[r] || (i[r] = []), i[r].push(s) } let a = t; for (let l = 0; l < i.length; ++l) { let h = i[l]; if (!h) continue; let u = 100, p = t + LiteGraph.NODE_TITLE_HEIGHT; for (let c = 0; c < h.length; ++c) { let d = h[c]; d.pos[0] = e == LiteGraph.VERTICAL_LAYOUT ? p : a, d.pos[1] = e == LiteGraph.VERTICAL_LAYOUT ? a : p; let g = e == LiteGraph.VERTICAL_LAYOUT ? 1 : 0; d.size[g] > u && (u = d.size[g]); let f = e == LiteGraph.VERTICAL_LAYOUT ? 0 : 1; p += d.size[f] + t + LiteGraph.NODE_TITLE_HEIGHT } a += u + t } this.setDirtyCanvas(!0, !0) }, LGraph.prototype.getTime = function () { return this.globaltime }, LGraph.prototype.getFixedTime = function () { return this.fixedtime }, LGraph.prototype.getElapsedTime = function () { return this.elapsed_time }, LGraph.prototype.sendEventToAllNodes = function (t, e, n) { n = n || LiteGraph.ALWAYS; var i = this._nodes_in_order ? this._nodes_in_order : this._nodes; if (i) for (var o = 0, s = i.length; o < s; ++o) { var r = i[o]; if (r.constructor === LiteGraph.Subgraph && "onExecute" != t) { r.mode == n && r.sendEventToAllNodes(t, e, n); continue } r[t] && r.mode == n && (void 0 === e ? r[t]() : e && e.constructor === Array ? r[t].apply(r, e) : r[t](e)) } }, LGraph.prototype.sendActionToCanvas = function (t, e) { if (this.list_of_graphcanvas) for (var n = 0; n < this.list_of_graphcanvas.length; ++n) { var i = this.list_of_graphcanvas[n]; i[t] && i[t].apply(i, e) } }, LGraph.prototype.add = function (t, e) { if (t) { if (t.constructor === LGraphGroup) { this._groups.push(t), this.setDirtyCanvas(!0), this.change(), t.graph = this, this._version++; return } if (-1 != t.id && null != this._nodes_by_id[t.id] && (console.warn("LiteGraph: there is already a node with this ID, changing it"), LiteGraph.use_uuids ? t.id = LiteGraph.uuidv4() : t.id = ++this.last_node_id), this._nodes.length >= LiteGraph.MAX_NUMBER_OF_NODES) throw "LiteGraph: max number of nodes in a graph reached"; return LiteGraph.use_uuids ? (null == t.id || -1 == t.id) && (t.id = LiteGraph.uuidv4()) : null == t.id || -1 == t.id ? t.id = ++this.last_node_id : this.last_node_id < t.id && (this.last_node_id = t.id), t.graph = this, this._version++, this._nodes.push(t), this._nodes_by_id[t.id] = t, t.onAdded && t.onAdded(this), this.config.align_to_grid && t.alignToGrid(), e || this.updateExecutionOrder(), this.onNodeAdded && this.onNodeAdded(t), this.setDirtyCanvas(!0), this.change(), t } }, LGraph.prototype.remove = function (t) { if (t.constructor === LiteGraph.LGraphGroup) { var e = this._groups.indexOf(t); -1 != e && this._groups.splice(e, 1), t.graph = null, this._version++, this.setDirtyCanvas(!0, !0), this.change(); return } if (null != this._nodes_by_id[t.id] && !t.ignore_remove) { if (this.beforeChange(), t.inputs) for (var n = 0; n < t.inputs.length; n++) { var i = t.inputs[n]; null != i.link && t.disconnectInput(n) } if (t.outputs) for (var n = 0; n < t.outputs.length; n++) { var i = t.outputs[n]; null != i.links && i.links.length && t.disconnectOutput(n) } if (t.onRemoved && t.onRemoved(), t.graph = null, this._version++, this.list_of_graphcanvas) for (var n = 0; n < this.list_of_graphcanvas.length; ++n) { var o = this.list_of_graphcanvas[n]; o.selected_nodes[t.id] && delete o.selected_nodes[t.id], o.node_dragged == t && (o.node_dragged = null) } var s = this._nodes.indexOf(t); -1 != s && this._nodes.splice(s, 1), delete this._nodes_by_id[t.id], this.onNodeRemoved && this.onNodeRemoved(t), this.sendActionToCanvas("checkPanels"), this.setDirtyCanvas(!0, !0), this.afterChange(), this.change(), this.updateExecutionOrder() } }, LGraph.prototype.getNodeById = function (t) { return null == t ? null : this._nodes_by_id[t] }, LGraph.prototype.findNodesByClass = function (t, e) { (e = e || []).length = 0; for (var n = 0, i = this._nodes.length; n < i; ++n)this._nodes[n].constructor === t && e.push(this._nodes[n]); return e }, LGraph.prototype.findNodesByType = function (t, e) { var t = t.toLowerCase(); (e = e || []).length = 0; for (var n = 0, i = this._nodes.length; n < i; ++n)this._nodes[n].type.toLowerCase() == t && e.push(this._nodes[n]); return e }, LGraph.prototype.findNodeByTitle = function (t) { for (var e = 0, n = this._nodes.length; e < n; ++e)if (this._nodes[e].title == t) return this._nodes[e]; return null }, LGraph.prototype.findNodesByTitle = function (t) { for (var e = [], n = 0, i = this._nodes.length; n < i; ++n)this._nodes[n].title == t && e.push(this._nodes[n]); return e }, LGraph.prototype.getNodeOnPos = function (t, e, n, i) { n = n || this._nodes; for (var o = null, s = n.length - 1; s >= 0; s--) { var r = n[s]; if (r.isPointInside(t, e, i)) return r } return o }, LGraph.prototype.getGroupOnPos = function (t, e) { for (var n = this._groups.length - 1; n >= 0; n--) { var i = this._groups[n]; if (i.isPointInside(t, e, 2, !0)) return i } return null }, LGraph.prototype.checkNodeTypes = function () { for (var t = !1, e = 0; e < this._nodes.length; e++) { var n = this._nodes[e], i = LiteGraph.registered_node_types[n.type]; if (n.constructor != i) { console.log("node being replaced by newer version: " + n.type); var o = LiteGraph.createNode(n.type); t = !0, this._nodes[e] = o, o.configure(n.serialize()), o.graph = this, this._nodes_by_id[o.id] = o, n.inputs && (o.inputs = n.inputs.concat()), n.outputs && (o.outputs = n.outputs.concat()) } } this.updateExecutionOrder() }, LGraph.prototype.onAction = function (t, e, n) { this._input_nodes = this.findNodesByClass(LiteGraph.GraphInput, this._input_nodes); for (var i = 0; i < this._input_nodes.length; ++i) { var o = this._input_nodes[i]; if (o.properties.name == t) { o.actionDo(t, e, n); break } } }, LGraph.prototype.trigger = function (t, e) { this.onTrigger && this.onTrigger(t, e) }, LGraph.prototype.addInput = function (t, e, n) { !this.inputs[t] && (this.beforeChange(), this.inputs[t] = { name: t, type: e, value: n }, this._version++, this.afterChange(), this.onInputAdded && this.onInputAdded(t, e), this.onInputsOutputsChange && this.onInputsOutputsChange()) }, LGraph.prototype.setInputData = function (t, e) { var n = this.inputs[t]; n && (n.value = e) }, LGraph.prototype.getInputData = function (t) { var e = this.inputs[t]; return e ? e.value : null }, LGraph.prototype.renameInput = function (t, e) { return e == t ? void 0 : !!this.inputs[t] && (this.inputs[e] ? (console.error("there is already one input with that name"), !1) : void (this.inputs[e] = this.inputs[t], delete this.inputs[t], this._version++, this.onInputRenamed && this.onInputRenamed(t, e), this.onInputsOutputsChange && this.onInputsOutputsChange())) }, LGraph.prototype.changeInputType = function (t, e) { if (!this.inputs[t]) return !1; (!this.inputs[t].type || String(this.inputs[t].type).toLowerCase() != String(e).toLowerCase()) && (this.inputs[t].type = e, this._version++, this.onInputTypeChanged && this.onInputTypeChanged(t, e)) }, LGraph.prototype.removeInput = function (t) { return !!this.inputs[t] && (delete this.inputs[t], this._version++, this.onInputRemoved && this.onInputRemoved(t), this.onInputsOutputsChange && this.onInputsOutputsChange(), !0) }, LGraph.prototype.addOutput = function (t, e, n) { this.outputs[t] = { name: t, type: e, value: n }, this._version++, this.onOutputAdded && this.onOutputAdded(t, e), this.onInputsOutputsChange && this.onInputsOutputsChange() }, LGraph.prototype.setOutputData = function (t, e) { var n = this.outputs[t]; n && (n.value = e) }, LGraph.prototype.getOutputData = function (t) { var e = this.outputs[t]; return e ? e.value : null }, LGraph.prototype.renameOutput = function (t, e) { return !!this.outputs[t] && (this.outputs[e] ? (console.error("there is already one output with that name"), !1) : void (this.outputs[e] = this.outputs[t], delete this.outputs[t], this._version++, this.onOutputRenamed && this.onOutputRenamed(t, e), this.onInputsOutputsChange && this.onInputsOutputsChange())) }, LGraph.prototype.changeOutputType = function (t, e) { if (!this.outputs[t]) return !1; (!this.outputs[t].type || String(this.outputs[t].type).toLowerCase() != String(e).toLowerCase()) && (this.outputs[t].type = e, this._version++, this.onOutputTypeChanged && this.onOutputTypeChanged(t, e)) }, LGraph.prototype.removeOutput = function (t) { return !!this.outputs[t] && (delete this.outputs[t], this._version++, this.onOutputRemoved && this.onOutputRemoved(t), this.onInputsOutputsChange && this.onInputsOutputsChange(), !0) }, LGraph.prototype.triggerInput = function (t, e) { for (var n = this.findNodesByTitle(t), i = 0; i < n.length; ++i)n[i].onTrigger(e) }, LGraph.prototype.setCallback = function (t, e) { for (var n = this.findNodesByTitle(t), i = 0; i < n.length; ++i)n[i].setTrigger(e) }, LGraph.prototype.beforeChange = function (t) { this.onBeforeChange && this.onBeforeChange(this, t), this.sendActionToCanvas("onBeforeChange", this) }, LGraph.prototype.afterChange = function (t) { this.onAfterChange && this.onAfterChange(this, t), this.sendActionToCanvas("onAfterChange", this) }, LGraph.prototype.connectionChange = function (t, e) { this.updateExecutionOrder(), this.onConnectionChange && this.onConnectionChange(t), this._version++, this.sendActionToCanvas("onConnectionChange") }, LGraph.prototype.isLive = function () { if (!this.list_of_graphcanvas) return !1; for (var t = 0; t < this.list_of_graphcanvas.length; ++t)if (this.list_of_graphcanvas[t].live_mode) return !0; return !1 }, LGraph.prototype.clearTriggeredSlots = function () { for (var t in this.links) { var e = this.links[t]; e && e._last_time && (e._last_time = 0) } }, LGraph.prototype.change = function () { LiteGraph.debug && console.log("Graph changed"), this.sendActionToCanvas("setDirty", [!0, !0]), this.on_change && this.on_change(this) }, LGraph.prototype.setDirtyCanvas = function (t, e) { this.sendActionToCanvas("setDirty", [t, e]) }, LGraph.prototype.removeLink = function (t) { var e = this.links[t]; if (e) { var n = this.getNodeById(e.target_id); n && n.disconnectInput(e.target_slot) } }, LGraph.prototype.serialize = function () { for (var t = [], e = 0, n = this._nodes.length; e < n; ++e)t.push(this._nodes[e].serialize()); var i = []; for (var e in this.links) { var o = this.links[e]; if (!o.serialize) { console.warn("weird LLink bug, link info is not a LLink but a regular object"); var s = new LLink; for (var r in o) s[r] = o[r]; this.links[e] = s, o = s } i.push(o.serialize()) } for (var a = [], e = 0; e < this._groups.length; ++e)a.push(this._groups[e].serialize()); var l = { last_node_id: this.last_node_id, last_link_id: this.last_link_id, nodes: t, links: i, groups: a, config: this.config, extra: this.extra, version: LiteGraph.VERSION }; return this.onSerialize && this.onSerialize(l), l }, LGraph.prototype.configure = function (t, e) { if (t) { e || this.clear(); var n = t.nodes; if (t.links && t.links.constructor === Array) { for (var i = [], o = 0; o < t.links.length; ++o) { var s = t.links[o]; if (!s) { console.warn("serialized graph link data contains errors, skipping."); continue } var r = new LLink; r.configure(s), i[r.id] = r } t.links = i } for (var o in t) "nodes" != o && "groups" != o && (this[o] = t[o]); var a = !1; if (this._nodes = [], n) { for (var o = 0, l = n.length; o < l; ++o) { var h = n[o], u = LiteGraph.createNode(h.type, h.title); u || (LiteGraph.debug && console.log("Node not found or has errors: " + h.type), (u = new LGraphNode).last_serialization = h, u.has_errors = !0, a = !0), u.id = h.id, this.add(u, !0) } for (var o = 0, l = n.length; o < l; ++o) { var h = n[o], u = this.getNodeById(h.id); u && u.configure(h) } } if (this._groups.length = 0, t.groups) for (var o = 0; o < t.groups.length; ++o) { var p = new LiteGraph.LGraphGroup; p.configure(t.groups[o]), this.add(p) } return this.updateExecutionOrder(), this.extra = t.extra || {}, this.onConfigure && this.onConfigure(t), this._version++, this.setDirtyCanvas(!0, !0), a } }, LGraph.prototype.load = function (t, e) { var n = this; if (t.constructor === File || t.constructor === Blob) { var i = new FileReader; i.addEventListener("load", function (t) { var i = JSON.parse(t.target.result); n.configure(i), e && e() }), i.readAsText(t); return } var o = new XMLHttpRequest; o.open("GET", t, !0), o.send(null), o.onload = function (t) { if (200 !== o.status) { console.error("Error loading graph:", o.status, o.response); return } var i = JSON.parse(o.response); n.configure(i), e && e() }, o.onerror = function (t) { console.error("Error loading graph:", t) } }, LGraph.prototype.onNodeTrace = function (t, e, n) { }, LLink.prototype.configure = function (t) { t.constructor === Array ? (this.id = t[0], this.origin_id = t[1], this.origin_slot = t[2], this.target_id = t[3], this.target_slot = t[4], this.type = t[5]) : (this.id = t.id, this.type = t.type, this.origin_id = t.origin_id, this.origin_slot = t.origin_slot, this.target_id = t.target_id, this.target_slot = t.target_slot) }, LLink.prototype.serialize = function () { return [this.id, this.origin_id, this.origin_slot, this.target_id, this.target_slot, this.type] }, LiteGraph.LLink = LLink, global.LGraphNode = LiteGraph.LGraphNode = LGraphNode, LGraphNode.prototype._ctor = function (t) { this.title = t || "Unnamed", this.size = [LiteGraph.NODE_WIDTH, 60], this.graph = null, this._pos = new Float32Array(10, 10), Object.defineProperty(this, "pos", { set: function (t) { t && !(t.length < 2) && (this._pos[0] = t[0], this._pos[1] = t[1]) }, get: function () { return this._pos }, enumerable: !0 }), LiteGraph.use_uuids ? this.id = LiteGraph.uuidv4() : this.id = -1, this.type = null, this.inputs = [], this.outputs = [], this.connections = [], this.properties = {}, this.properties_info = [], this.flags = {} }, LGraphNode.prototype.configure = function (t) { for (var e in this.graph && this.graph._version++, t) { if ("properties" == e) { for (var n in t.properties) this.properties[n] = t.properties[n], this.onPropertyChanged && this.onPropertyChanged(n, t.properties[n]); continue } null != t[e] && ("object" == typeof t[e] ? this[e] && this[e].configure ? this[e].configure(t[e]) : this[e] = LiteGraph.cloneObject(t[e], this[e]) : this[e] = t[e]) } if (t.title || (this.title = this.constructor.title), this.inputs) for (var i = 0; i < this.inputs.length; ++i) { var o = this.inputs[i], s = this.graph ? this.graph.links[o.link] : null; this.onConnectionsChange && this.onConnectionsChange(LiteGraph.INPUT, i, !0, s, o), this.onInputAdded && this.onInputAdded(o) } if (this.outputs) for (var i = 0; i < this.outputs.length; ++i) { var r = this.outputs[i]; if (r.links) { for (var e = 0; e < r.links.length; ++e) { var s = this.graph ? this.graph.links[r.links[e]] : null; this.onConnectionsChange && this.onConnectionsChange(LiteGraph.OUTPUT, i, !0, s, r) } this.onOutputAdded && this.onOutputAdded(r) } } if (this.widgets) { for (var i = 0; i < this.widgets.length; ++i) { var a = this.widgets[i]; a && a.options && a.options.property && void 0 != this.properties[a.options.property] && (a.value = JSON.parse(JSON.stringify(this.properties[a.options.property]))) } if (t.widgets_values) for (var i = 0; i < t.widgets_values.length; ++i)this.widgets[i] && (this.widgets[i].value = t.widgets_values[i]) } this.onConfigure && this.onConfigure(t) }, LGraphNode.prototype.serialize = function () { var t = { id: this.id, type: this.type, pos: this.pos, size: this.size, flags: LiteGraph.cloneObject(this.flags), order: this.order, mode: this.mode }; if (this.constructor === LGraphNode && this.last_serialization) return this.last_serialization; if (this.inputs && (t.inputs = this.inputs), this.outputs) { for (var e = 0; e < this.outputs.length; e++)delete this.outputs[e]._data; t.outputs = this.outputs } if (this.title && this.title != this.constructor.title && (t.title = this.title), this.properties && (t.properties = LiteGraph.cloneObject(this.properties)), this.widgets && this.serialize_widgets) { t.widgets_values = []; for (var e = 0; e < this.widgets.length; ++e)this.widgets[e] ? t.widgets_values[e] = this.widgets[e].value : t.widgets_values[e] = null } return t.type || (t.type = this.constructor.type), this.color && (t.color = this.color), this.bgcolor && (t.bgcolor = this.bgcolor), this.boxcolor && (t.boxcolor = this.boxcolor), this.shape && (t.shape = this.shape), this.onSerialize && this.onSerialize(t) && console.warn("node onSerialize shouldnt return anything, data should be stored in the object pass in the first parameter"), t }, LGraphNode.prototype.clone = function () { var t = LiteGraph.createNode(this.type); if (!t) return null; var e = LiteGraph.cloneObject(this.serialize()); if (e.inputs) for (var n = 0; n < e.inputs.length; ++n)e.inputs[n].link = null; if (e.outputs) for (var n = 0; n < e.outputs.length; ++n)e.outputs[n].links && (e.outputs[n].links.length = 0); return delete e.id, LiteGraph.use_uuids && (e.id = LiteGraph.uuidv4()), t.configure(e), t }, LGraphNode.prototype.toString = function () { return JSON.stringify(this.serialize()) }, LGraphNode.prototype.getTitle = function () { return this.title || this.constructor.title }, LGraphNode.prototype.setProperty = function (t, e) { if (this.properties || (this.properties = {}), e !== this.properties[t]) { var n = this.properties[t]; if (this.properties[t] = e, this.onPropertyChanged && !1 === this.onPropertyChanged(t, e, n) && (this.properties[t] = n), this.widgets) for (var i = 0; i < this.widgets.length; ++i) { var o = this.widgets[i]; if (o && o.options.property == t) { o.value = e; break } } } }, LGraphNode.prototype.setOutputData = function (t, e) { if (this.outputs && -1 != t && !(t >= this.outputs.length)) { var n = this.outputs[t]; if (n && (n._data = e, this.outputs[t].links)) for (var i = 0; i < this.outputs[t].links.length; i++) { var o = this.outputs[t].links[i], s = this.graph.links[o]; s && (s.data = e) } } }, LGraphNode.prototype.setOutputDataType = function (t, e) { if (this.outputs && -1 != t && !(t >= this.outputs.length)) { var n = this.outputs[t]; if (n && (n.type = e, this.outputs[t].links)) for (var i = 0; i < this.outputs[t].links.length; i++) { var o = this.outputs[t].links[i]; this.graph.links[o].type = e } } }, LGraphNode.prototype.getInputData = function (t, e) { if (this.inputs && !(t >= this.inputs.length) && null != this.inputs[t].link) { var n = this.inputs[t].link, i = this.graph.links[n]; if (!i) return null; if (!e) return i.data; var o = this.graph.getNodeById(i.origin_id); return o && (o.updateOutputData ? o.updateOutputData(i.origin_slot) : o.onExecute && o.onExecute()), i.data } }, LGraphNode.prototype.getInputDataType = function (t) { if (!this.inputs || t >= this.inputs.length || null == this.inputs[t].link) return null; var e = this.inputs[t].link, n = this.graph.links[e]; if (!n) return null; var i = this.graph.getNodeById(n.origin_id); if (!i) return n.type; var o = i.outputs[n.origin_slot]; return o ? o.type : null }, LGraphNode.prototype.getInputDataByName = function (t, e) { var n = this.findInputSlot(t); return -1 == n ? null : this.getInputData(n, e) }, LGraphNode.prototype.isInputConnected = function (t) { return !!this.inputs && t < this.inputs.length && null != this.inputs[t].link }, LGraphNode.prototype.getInputInfo = function (t) { return this.inputs && t < this.inputs.length ? this.inputs[t] : null }, LGraphNode.prototype.getInputLink = function (t) { if (!this.inputs) return null; if (t < this.inputs.length) { var e = this.inputs[t]; return this.graph.links[e.link] } return null }, LGraphNode.prototype.getInputNode = function (t) { if (!this.inputs || t >= this.inputs.length) return null; var e = this.inputs[t]; if (!e || null === e.link) return null; var n = this.graph.links[e.link]; return n ? this.graph.getNodeById(n.origin_id) : null }, LGraphNode.prototype.getInputOrProperty = function (t) { if (!this.inputs || !this.inputs.length) return this.properties ? this.properties[t] : null; for (var e = 0, n = this.inputs.length; e < n; ++e) { var i = this.inputs[e]; if (t == i.name && null != i.link) { var o = this.graph.links[i.link]; if (o) return o.data } } return this.properties[t] }, LGraphNode.prototype.getOutputData = function (t) { return !this.outputs || t >= this.outputs.length ? null : (0, this.outputs[t]._data) }, LGraphNode.prototype.getOutputInfo = function (t) { return this.outputs && t < this.outputs.length ? this.outputs[t] : null }, LGraphNode.prototype.isOutputConnected = function (t) { return !!this.outputs && t < this.outputs.length && this.outputs[t].links && this.outputs[t].links.length }, LGraphNode.prototype.isAnyOutputConnected = function () { if (!this.outputs) return !1; for (var t = 0; t < this.outputs.length; ++t)if (this.outputs[t].links && this.outputs[t].links.length) return !0; return !1 }, LGraphNode.prototype.getOutputNodes = function (t) { if (!this.outputs || 0 == this.outputs.length || t >= this.outputs.length) return null; var e = this.outputs[t]; if (!e.links || 0 == e.links.length) return null; for (var n = [], i = 0; i < e.links.length; i++) { var o = e.links[i], s = this.graph.links[o]; if (s) { var r = this.graph.getNodeById(s.target_id); r && n.push(r) } } return n }, LGraphNode.prototype.addOnTriggerInput = function () { var t = this.findInputSlot("onTrigger"); return -1 == t ? (this.addInput("onTrigger", LiteGraph.EVENT, { optional: !0, nameLocked: !0 }), this.findInputSlot("onTrigger")) : t }, LGraphNode.prototype.addOnExecutedOutput = function () { var t = this.findOutputSlot("onExecuted"); return -1 == t ? (this.addOutput("onExecuted", LiteGraph.ACTION, { optional: !0, nameLocked: !0 }), this.findOutputSlot("onExecuted")) : t }, LGraphNode.prototype.onAfterExecuteNode = function (t, e) { var n = this.findOutputSlot("onExecuted"); -1 != n && this.triggerSlot(n, t, null, e) }, LGraphNode.prototype.changeMode = function (t) { switch (t) { case LiteGraph.ON_EVENT: break; case LiteGraph.ON_TRIGGER: this.addOnTriggerInput(), this.addOnExecutedOutput(); break; case LiteGraph.NEVER: case LiteGraph.ALWAYS: case LiteGraph.ON_REQUEST: break; default: return !1 }return this.mode = t, !0 }, LGraphNode.prototype.executePendingActions = function () { if (this._waiting_actions && this._waiting_actions.length) { for (var t = 0; t < this._waiting_actions.length; ++t) { var e = this._waiting_actions[t]; this.onAction(e[0], e[1], e[2], e[3], e[4]) } this._waiting_actions.length = 0 } }, LGraphNode.prototype.doExecute = function (t, e) { e = e || {}, this.onExecute && (e.action_call || (e.action_call = this.id + "_exec_" + Math.floor(9999 * Math.random())), this.graph.nodes_executing[this.id] = !0, this.onExecute(t, e), this.graph.nodes_executing[this.id] = !1, this.exec_version = this.graph.iteration, e && e.action_call && (this.action_call = e.action_call, this.graph.nodes_executedAction[this.id] = e.action_call)), this.execute_triggered = 2, this.onAfterExecuteNode && this.onAfterExecuteNode(t, e) }, LGraphNode.prototype.actionDo = function (t, e, n, i) { n = n || {}, this.onAction && (n.action_call || (n.action_call = this.id + "_" + (t || "action") + "_" + Math.floor(9999 * Math.random())), this.graph.nodes_actioning[this.id] = t || "actioning", this.onAction(t, e, n, i), this.graph.nodes_actioning[this.id] = !1, n && n.action_call && (this.action_call = n.action_call, this.graph.nodes_executedAction[this.id] = n.action_call)), this.action_triggered = 2, this.onAfterExecuteNode && this.onAfterExecuteNode(e, n) }, LGraphNode.prototype.trigger = function (t, e, n) { if (this.outputs && this.outputs.length) { this.graph && (this.graph._last_trigger_time = LiteGraph.getTime()); for (var i = 0; i < this.outputs.length; ++i) { var o = this.outputs[i]; o && o.type === LiteGraph.EVENT && (!t || o.name == t) && this.triggerSlot(i, e, null, n) } } }, LGraphNode.prototype.triggerSlot = function (t, e, n, i) { if (i = i || {}, this.outputs) { if (null == t) { console.error("slot must be a number"); return } t.constructor !== Number && console.warn("slot must be a number, use node.trigger('name') if you want to use a string"); var o = this.outputs[t]; if (o) { var s = o.links; if (s && s.length) { this.graph && (this.graph._last_trigger_time = LiteGraph.getTime()); for (var r = 0; r < s.length; ++r) { var a = s[r]; if (null == n || n == a) { var l = this.graph.links[s[r]]; if (l) { l._last_time = LiteGraph.getTime(); var h = this.graph.getNodeById(l.target_id); if (h) { var u = h.inputs[l.target_slot]; if (h.mode === LiteGraph.ON_TRIGGER) i.action_call || (i.action_call = this.id + "_trigg_" + Math.floor(9999 * Math.random())), h.onExecute && h.doExecute(e, i); else if (h.onAction) { i.action_call || (i.action_call = this.id + "_act_" + Math.floor(9999 * Math.random())); var u = h.inputs[l.target_slot]; LiteGraph.use_deferred_actions && h.onExecute ? (h._waiting_actions || (h._waiting_actions = []), h._waiting_actions.push([u.name, e, i, l.target_slot])) : h.actionDo(u.name, e, i, l.target_slot) } } } } } } } } }, LGraphNode.prototype.clearTriggeredSlot = function (t, e) { if (this.outputs) { var n = this.outputs[t]; if (n) { var i = n.links; if (i && i.length) for (var o = 0; o < i.length; ++o) { var s = i[o]; if (null == e || e == s) { var r = this.graph.links[i[o]]; r && (r._last_time = 0) } } } } }, LGraphNode.prototype.setSize = function (t) { this.size = t, this.onResize && this.onResize(this.size) }, LGraphNode.prototype.addProperty = function (t, e, n, i) { var o = { name: t, type: n, default_value: e }; if (i) for (var s in i) o[s] = i[s]; return this.properties_info || (this.properties_info = []), this.properties_info.push(o), this.properties || (this.properties = {}), this.properties[t] = e, o }, LGraphNode.prototype.addOutput = function (t, e, n) { var i = { name: t, type: e, links: null }; if (n) for (var o in n) i[o] = n[o]; return this.outputs || (this.outputs = []), this.outputs.push(i), this.onOutputAdded && this.onOutputAdded(i), LiteGraph.auto_load_slot_types && LiteGraph.registerNodeAndSlotType(this, e, !0), this.setSize(this.computeSize()), this.setDirtyCanvas(!0, !0), i }, LGraphNode.prototype.addOutputs = function (t) { for (var e = 0; e < t.length; ++e) { var n = t[e], i = { name: n[0], type: n[1], link: null }; if (t[2]) for (var o in n[2]) i[o] = n[2][o]; this.outputs || (this.outputs = []), this.outputs.push(i), this.onOutputAdded && this.onOutputAdded(i), LiteGraph.auto_load_slot_types && LiteGraph.registerNodeAndSlotType(this, n[1], !0) } this.setSize(this.computeSize()), this.setDirtyCanvas(!0, !0) }, LGraphNode.prototype.removeOutput = function (t) { this.disconnectOutput(t), this.outputs.splice(t, 1); for (var e = t; e < this.outputs.length; ++e)if (this.outputs[e] && this.outputs[e].links) for (var n = this.outputs[e].links, i = 0; i < n.length; ++i) { var o = this.graph.links[n[i]]; o && (o.origin_slot -= 1) } this.setSize(this.computeSize()), this.onOutputRemoved && this.onOutputRemoved(t), this.setDirtyCanvas(!0, !0) }, LGraphNode.prototype.addInput = function (t, e, n) { e = e || 0; var i = { name: t, type: e, link: null }; if (n) for (var o in n) i[o] = n[o]; return this.inputs || (this.inputs = []), this.inputs.push(i), this.setSize(this.computeSize()), this.onInputAdded && this.onInputAdded(i), LiteGraph.registerNodeAndSlotType(this, e), this.setDirtyCanvas(!0, !0), i }, LGraphNode.prototype.addInputs = function (t) { for (var e = 0; e < t.length; ++e) { var n = t[e], i = { name: n[0], type: n[1], link: null }; if (t[2]) for (var o in n[2]) i[o] = n[2][o]; this.inputs || (this.inputs = []), this.inputs.push(i), this.onInputAdded && this.onInputAdded(i), LiteGraph.registerNodeAndSlotType(this, n[1]) } this.setSize(this.computeSize()), this.setDirtyCanvas(!0, !0) }, LGraphNode.prototype.removeInput = function (t) { this.disconnectInput(t); for (var e = this.inputs.splice(t, 1), n = t; n < this.inputs.length; ++n) { if (this.inputs[n]) { var i = this.graph.links[this.inputs[n].link]; i && (i.target_slot -= 1) } } this.setSize(this.computeSize()), this.onInputRemoved && this.onInputRemoved(t, e[0]), this.setDirtyCanvas(!0, !0) }, LGraphNode.prototype.addConnection = function (t, e, n, i) { var o = { name: t, type: e, pos: n, direction: i, links: null }; return this.connections.push(o), o }, LGraphNode.prototype.computeSize = function (t) { if (this.constructor.size) return this.constructor.size.concat(); var e = Math.max(this.inputs ? this.inputs.length : 1, this.outputs ? this.outputs.length : 1), n = t || new Float32Array([0, 0]); e = Math.max(e, 1); var i = LiteGraph.NODE_TEXT_SIZE, o = g(this.title), s = 0, r = 0; if (this.inputs) for (var a = 0, l = this.inputs.length; a < l; ++a) { var h = this.inputs[a], u = h.label || h.name || "", p = g(u); s < p && (s = p) } if (this.outputs) for (var a = 0, l = this.outputs.length; a < l; ++a) { var c = this.outputs[a], u = c.label || c.name || "", p = g(u); r < p && (r = p) } n[0] = Math.max(s + r + 10, o), n[0] = Math.max(n[0], LiteGraph.NODE_WIDTH), this.widgets && this.widgets.length && (n[0] = Math.max(n[0], 1.5 * LiteGraph.NODE_WIDTH)), n[1] = (this.constructor.slot_start_y || 0) + e * LiteGraph.NODE_SLOT_HEIGHT; var d = 0; if (this.widgets && this.widgets.length) { for (var a = 0, l = this.widgets.length; a < l; ++a)this.widgets[a].computeSize ? d += this.widgets[a].computeSize(n[0])[1] + 4 : d += LiteGraph.NODE_WIDGET_HEIGHT + 4; d += 8 } function g(t) { return t ? i * t.length * .6 : 0 } return this.widgets_up ? n[1] = Math.max(n[1], d) : null != this.widgets_start_y ? n[1] = Math.max(n[1], d + this.widgets_start_y) : n[1] += d, this.constructor.min_height && n[1] < this.constructor.min_height && (n[1] = this.constructor.min_height), n[1] += 6, n }, LGraphNode.prototype.getPropertyInfo = function (t) { var e = null; if (this.properties_info) { for (var n = 0; n < this.properties_info.length; ++n)if (this.properties_info[n].name == t) { e = this.properties_info[n]; break } } return this.constructor["@" + t] && (e = this.constructor["@" + t]), this.constructor.widgets_info && this.constructor.widgets_info[t] && (e = this.constructor.widgets_info[t]), !e && this.onGetPropertyInfo && (e = this.onGetPropertyInfo(t)), e || (e = {}), e.type || (e.type = typeof this.properties[t]), "combo" == e.widget && (e.type = "enum"), e }, LGraphNode.prototype.addWidget = function (t, e, n, i, o) { this.widgets || (this.widgets = []), !o && i && i.constructor === Object && (o = i, i = null), o && o.constructor === String && (o = { property: o }), i && i.constructor === String && (o || (o = {}), o.property = i, i = null), i && i.constructor !== Function && (console.warn("addWidget: callback must be a function"), i = null); var s = { type: t.toLowerCase(), name: e, value: n, callback: i, options: o || {} }; if (void 0 !== s.options.y && (s.y = s.options.y), i || s.options.callback || s.options.property || console.warn("LiteGraph addWidget(...) without a callback or property assigned"), "combo" == t && !s.options.values) throw "LiteGraph addWidget('combo',...) requires to pass values in options: { values:['red','blue'] }"; return this.widgets.push(s), this.setSize(this.computeSize()), s }, LGraphNode.prototype.addCustomWidget = function (t) { return this.widgets || (this.widgets = []), this.widgets.push(t), t }, LGraphNode.prototype.getBounding = function (t, e) { t = t || new Float32Array(4); let n = this.pos, i = this.flags.collapsed, o = this.size, s = 0, r = 1, a = 0, l = 0; return e && (r = 6 + (s = 4), l = 5 + (a = 4)), t[0] = n[0] - s, t[1] = n[1] - LiteGraph.NODE_TITLE_HEIGHT - a, t[2] = i ? (this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH) + r : o[0] + r, t[3] = i ? LiteGraph.NODE_TITLE_HEIGHT + l : o[1] + LiteGraph.NODE_TITLE_HEIGHT + l, this.onBounding && this.onBounding(t), t }, LGraphNode.prototype.isPointInside = function (t, e, n, i) { n = n || 0; var o = this.graph && this.graph.isLive() ? 0 : LiteGraph.NODE_TITLE_HEIGHT; if (i && (o = 0), this.flags && this.flags.collapsed) { if (isInsideRectangle(t, e, this.pos[0] - n, this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT - n, (this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH) + 2 * n, LiteGraph.NODE_TITLE_HEIGHT + 2 * n)) return !0 } else if (this.pos[0] - 4 - n < t && this.pos[0] + this.size[0] + 4 + n > t && this.pos[1] - o - n < e && this.pos[1] + this.size[1] + n > e) return !0; return !1 }, LGraphNode.prototype.getSlotInPosition = function (t, e) { var n = new Float32Array(2); if (this.inputs) for (var i = 0, o = this.inputs.length; i < o; ++i) { var s = this.inputs[i]; if (this.getConnectionPos(!0, i, n), isInsideRectangle(t, e, n[0] - 10, n[1] - 5, 20, 10)) return { input: s, slot: i, link_pos: n } } if (this.outputs) for (var i = 0, o = this.outputs.length; i < o; ++i) { var r = this.outputs[i]; if (this.getConnectionPos(!1, i, n), isInsideRectangle(t, e, n[0] - 10, n[1] - 5, 20, 10)) return { output: r, slot: i, link_pos: n } } return null }, LGraphNode.prototype.findInputSlot = function (t, e) { if (!this.inputs) return -1; for (var n = 0, i = this.inputs.length; n < i; ++n)if (t == this.inputs[n].name) return e ? this.inputs[n] : n; return -1 }, LGraphNode.prototype.findOutputSlot = function (t, e) { if (e = e || !1, !this.outputs) return -1; for (var n = 0, i = this.outputs.length; n < i; ++n)if (t == this.outputs[n].name) return e ? this.outputs[n] : n; return -1 }, LGraphNode.prototype.findInputSlotFree = function (t) { var t = t || {}, e = Object.assign({ returnObj: !1, typesNotAccepted: [] }, t); if (!this.inputs) return -1; for (var n = 0, i = this.inputs.length; n < i; ++n)if (!(this.inputs[n].link && null != this.inputs[n].link || e.typesNotAccepted && e.typesNotAccepted.includes && e.typesNotAccepted.includes(this.inputs[n].type))) return e.returnObj ? this.inputs[n] : n; return -1 }, LGraphNode.prototype.findOutputSlotFree = function (t) { var t = t || {}, e = Object.assign({ returnObj: !1, typesNotAccepted: [] }, t); if (!this.outputs) return -1; for (var n = 0, i = this.outputs.length; n < i; ++n)if (!(this.outputs[n].links && null != this.outputs[n].links || e.typesNotAccepted && e.typesNotAccepted.includes && e.typesNotAccepted.includes(this.outputs[n].type))) return e.returnObj ? this.outputs[n] : n; return -1 }, LGraphNode.prototype.findInputSlotByType = function (t, e, n, i) { return this.findSlotByType(!0, t, e, n, i) }, LGraphNode.prototype.findOutputSlotByType = function (t, e, n, i) { return this.findSlotByType(!1, t, e, n, i) }, LGraphNode.prototype.findSlotByType = function (t, e, n, i, o) { n = n || !1, i = i || !1, o = o || !1; var s = (t = t || !1) ? this.inputs : this.outputs; if (!s) return -1; ("" == e || "*" == e) && (e = 0); for (var r = 0, a = s.length; r < a; ++r) { var l = (e + "").toLowerCase().split(","), h = "0" == s[r].type || "*" == s[r].type ? "0" : s[r].type; h = (h + "").toLowerCase().split(","); for (var u = 0; u < l.length; u++)for (var p = 0; p < h.length; p++)if ("_event_" == l[u] && (l[u] = LiteGraph.EVENT), "_event_" == h[u] && (h[u] = LiteGraph.EVENT), "*" == l[u] && (l[u] = 0), "*" == h[u] && (h[u] = 0), l[u] == h[p]) { if (i && s[r].links && null !== s[r].links) continue; return n ? s[r] : r } } if (i && !o) for (var r = 0, a = s.length; r < a; ++r) { var l = (e + "").toLowerCase().split(","), h = "0" == s[r].type || "*" == s[r].type ? "0" : s[r].type; h = (h + "").toLowerCase().split(","); for (var u = 0; u < l.length; u++)for (var p = 0; p < h.length; p++)if ("*" == l[u] && (l[u] = 0), "*" == h[u] && (h[u] = 0), l[u] == h[p]) return n ? s[r] : r } return -1 }, LGraphNode.prototype.connectByType = function (t, e, n, i) { var i = i || {}, o = Object.assign({ createEventInCase: !0, firstFreeIfOutputGeneralInCase: !0, generalTypeInCase: !0 }, i); e && e.constructor === Number && (e = this.graph.getNodeById(e)); var s = e.findInputSlotByType(n, !1, !0); if (s >= 0 && null !== s) return this.connect(t, e, s); if (o.createEventInCase && n == LiteGraph.EVENT) return this.connect(t, e, -1); if (o.generalTypeInCase) { var s = e.findInputSlotByType(0, !1, !0, !0); if (s >= 0) return this.connect(t, e, s) } if (o.firstFreeIfOutputGeneralInCase && (0 == n || "*" == n || "" == n)) { var s = e.findInputSlotFree({ typesNotAccepted: [LiteGraph.EVENT] }); if (s >= 0) return this.connect(t, e, s) } return console.debug("no way to connect type: ", n, " to targetNODE ", e), null }, LGraphNode.prototype.connectByTypeOutput = function (t, e, n, i) { var i = i || {}, o = Object.assign({ createEventInCase: !0, firstFreeIfInputGeneralInCase: !0, generalTypeInCase: !0 }, i); e && e.constructor === Number && (e = this.graph.getNodeById(e)); var s = e.findOutputSlotByType(n, !1, !0); if (s >= 0 && null !== s) return e.connect(s, this, t); if (o.generalTypeInCase) { var s = e.findOutputSlotByType(0, !1, !0, !0); if (s >= 0) return e.connect(s, this, t) } if (o.createEventInCase && n == LiteGraph.EVENT && LiteGraph.do_add_triggers_slots) { var s = e.addOnExecutedOutput(); return e.connect(s, this, t) } if (o.firstFreeIfInputGeneralInCase && (0 == n || "*" == n || "" == n)) { var s = e.findOutputSlotFree({ typesNotAccepted: [LiteGraph.EVENT] }); if (s >= 0) return e.connect(s, this, t) } return console.debug("no way to connect byOUT type: ", n, " to sourceNODE ", e), null }, LGraphNode.prototype.connect = function (t, e, n) { if (n = n || 0, !this.graph) return console.log("Connect: Error, node doesn't belong to any graph. Nodes must be added first to a graph before connecting them."), null; if (t.constructor === String) { if (-1 == (t = this.findOutputSlot(t))) return LiteGraph.debug && console.log("Connect: Error, no slot of name " + t), null } else if (!this.outputs || t >= this.outputs.length) return LiteGraph.debug && console.log("Connect: Error, slot number not found"), null; if (e && e.constructor === Number && (e = this.graph.getNodeById(e)), !e) throw "target node is null"; if (e == this) return null; if (n.constructor === String) { if (-1 == (n = e.findInputSlot(n))) return LiteGraph.debug && console.log("Connect: Error, no slot of name " + n), null } else if (n === LiteGraph.EVENT) { if (!LiteGraph.do_add_triggers_slots) return null; e.changeMode(LiteGraph.ON_TRIGGER), n = e.findInputSlot("onTrigger") } else if (!e.inputs || n >= e.inputs.length) return LiteGraph.debug && console.log("Connect: Error, slot number not found"), null; var i, o = !1, s = e.inputs[n], r = null, a = this.outputs[t]; return this.outputs[t] ? (e.onBeforeConnectInput && (n = e.onBeforeConnectInput(n)), !1 !== n && null !== n && LiteGraph.isValidConnection(a.type, s.type)) ? e.onConnectInput && !1 === e.onConnectInput(n, a.type, a, this, t) || this.onConnectOutput && !1 === this.onConnectOutput(t, s.type, s, e, n) ? null : (e.inputs[n] && null != e.inputs[n].link && (this.graph.beforeChange(), e.disconnectInput(n, { doProcessChange: !1 }), o = !0), null !== a.links && a.links.length && a.type === LiteGraph.EVENT && !LiteGraph.allow_multi_output_for_events && (this.graph.beforeChange(), this.disconnectOutput(t, !1, { doProcessChange: !1 }), o = !0), i = LiteGraph.use_uuids ? LiteGraph.uuidv4() : ++this.graph.last_link_id, r = new LLink(i, s.type || a.type, this.id, t, e.id, n), this.graph.links[r.id] = r, null == a.links && (a.links = []), a.links.push(r.id), e.inputs[n].link = r.id, this.graph && this.graph._version++, this.onConnectionsChange && this.onConnectionsChange(LiteGraph.OUTPUT, t, !0, r, a), e.onConnectionsChange && e.onConnectionsChange(LiteGraph.INPUT, n, !0, r, s), this.graph && this.graph.onNodeConnectionChange && (this.graph.onNodeConnectionChange(LiteGraph.INPUT, e, n, this, t), this.graph.onNodeConnectionChange(LiteGraph.OUTPUT, this, t, e, n)), this.setDirtyCanvas(!1, !0), this.graph.afterChange(), this.graph.connectionChange(this, r), r) : (this.setDirtyCanvas(!1, !0), o && this.graph.connectionChange(this, r), null) : null }, LGraphNode.prototype.disconnectOutput = function (t, e) { if (t.constructor === String) { if (-1 == (t = this.findOutputSlot(t))) return LiteGraph.debug && console.log("Connect: Error, no slot of name " + t), !1 } else if (!this.outputs || t >= this.outputs.length) return LiteGraph.debug && console.log("Connect: Error, slot number not found"), !1; var n = this.outputs[t]; if (!n || !n.links || 0 == n.links.length) return !1; if (e) { if (e.constructor === Number && (e = this.graph.getNodeById(e)), !e) throw "Target Node not found"; for (var i = 0, o = n.links.length; i < o; i++) { var s = n.links[i], r = this.graph.links[s]; if (r.target_id == e.id) { n.links.splice(i, 1); var a = e.inputs[r.target_slot]; a.link = null, delete this.graph.links[s], this.graph && this.graph._version++, e.onConnectionsChange && e.onConnectionsChange(LiteGraph.INPUT, r.target_slot, !1, r, a), this.onConnectionsChange && this.onConnectionsChange(LiteGraph.OUTPUT, t, !1, r, n), this.graph && this.graph.onNodeConnectionChange && this.graph.onNodeConnectionChange(LiteGraph.OUTPUT, this, t), this.graph && this.graph.onNodeConnectionChange && (this.graph.onNodeConnectionChange(LiteGraph.OUTPUT, this, t), this.graph.onNodeConnectionChange(LiteGraph.INPUT, e, r.target_slot)); break } } } else { for (var i = 0, o = n.links.length; i < o; i++) { var s = n.links[i], r = this.graph.links[s]; if (r) { var e = this.graph.getNodeById(r.target_id), a = null; this.graph && this.graph._version++, e && ((a = e.inputs[r.target_slot]).link = null, e.onConnectionsChange && e.onConnectionsChange(LiteGraph.INPUT, r.target_slot, !1, r, a), this.graph && this.graph.onNodeConnectionChange && this.graph.onNodeConnectionChange(LiteGraph.INPUT, e, r.target_slot)), delete this.graph.links[s], this.onConnectionsChange && this.onConnectionsChange(LiteGraph.OUTPUT, t, !1, r, n), this.graph && this.graph.onNodeConnectionChange && (this.graph.onNodeConnectionChange(LiteGraph.OUTPUT, this, t), this.graph.onNodeConnectionChange(LiteGraph.INPUT, e, r.target_slot)) } } n.links = null } return this.setDirtyCanvas(!1, !0), this.graph.connectionChange(this), !0 }, LGraphNode.prototype.disconnectInput = function (t) { if (t.constructor === String) { if (-1 == (t = this.findInputSlot(t))) return LiteGraph.debug && console.log("Connect: Error, no slot of name " + t), !1 } else if (!this.inputs || t >= this.inputs.length) return LiteGraph.debug && console.log("Connect: Error, slot number not found"), !1; var e = this.inputs[t]; if (!e) return !1; var n = this.inputs[t].link; if (null != n) { this.inputs[t].link = null; var i = this.graph.links[n]; if (i) { var o = this.graph.getNodeById(i.origin_id); if (!o) return !1; var s = o.outputs[i.origin_slot]; if (!s || !s.links || 0 == s.links.length) return !1; for (var r = 0, a = s.links.length; r < a; r++)if (s.links[r] == n) { s.links.splice(r, 1); break } delete this.graph.links[n], this.graph && this.graph._version++, this.onConnectionsChange && this.onConnectionsChange(LiteGraph.INPUT, t, !1, i, e), o.onConnectionsChange && o.onConnectionsChange(LiteGraph.OUTPUT, r, !1, i, s), this.graph && this.graph.onNodeConnectionChange && (this.graph.onNodeConnectionChange(LiteGraph.OUTPUT, o, r), this.graph.onNodeConnectionChange(LiteGraph.INPUT, this, t)) } } return this.setDirtyCanvas(!1, !0), this.graph && this.graph.connectionChange(this), !0 }, LGraphNode.prototype.getConnectionPos = function (t, e, n) { n = n || new Float32Array(2); var i = 0; t && this.inputs && (i = this.inputs.length), !t && this.outputs && (i = this.outputs.length); var o = .5 * LiteGraph.NODE_SLOT_HEIGHT; if (this.flags.collapsed) { var s = this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH; return this.horizontal ? (n[0] = this.pos[0] + .5 * s, t ? n[1] = this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT : n[1] = this.pos[1]) : (t ? n[0] = this.pos[0] : n[0] = this.pos[0] + s, n[1] = this.pos[1] - .5 * LiteGraph.NODE_TITLE_HEIGHT), n } return t && -1 == e ? (n[0] = this.pos[0] + .5 * LiteGraph.NODE_TITLE_HEIGHT, n[1] = this.pos[1] + .5 * LiteGraph.NODE_TITLE_HEIGHT, n) : t && i > e && this.inputs[e].pos ? (n[0] = this.pos[0] + this.inputs[e].pos[0], n[1] = this.pos[1] + this.inputs[e].pos[1], n) : !t && i > e && this.outputs[e].pos ? (n[0] = this.pos[0] + this.outputs[e].pos[0], n[1] = this.pos[1] + this.outputs[e].pos[1], n) : this.horizontal ? (n[0] = this.pos[0] + (e + .5) * (this.size[0] / i), t ? n[1] = this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT : n[1] = this.pos[1] + this.size[1], n) : (t ? n[0] = this.pos[0] + o : n[0] = this.pos[0] + this.size[0] + 1 - o, n[1] = this.pos[1] + (e + .7) * LiteGraph.NODE_SLOT_HEIGHT + (this.constructor.slot_start_y || 0), n) }, LGraphNode.prototype.alignToGrid = function () { this.pos[0] = LiteGraph.CANVAS_GRID_SIZE * Math.round(this.pos[0] / LiteGraph.CANVAS_GRID_SIZE), this.pos[1] = LiteGraph.CANVAS_GRID_SIZE * Math.round(this.pos[1] / LiteGraph.CANVAS_GRID_SIZE) }, LGraphNode.prototype.trace = function (t) { this.console || (this.console = []), this.console.push(t), this.console.length > LGraphNode.MAX_CONSOLE && this.console.shift(), this.graph.onNodeTrace && this.graph.onNodeTrace(this, t) }, LGraphNode.prototype.setDirtyCanvas = function (t, e) { this.graph && this.graph.sendActionToCanvas("setDirty", [t, e]) }, LGraphNode.prototype.loadImage = function (t) { var e = new Image; e.src = LiteGraph.node_images_path + t, e.ready = !1; var n = this; return e.onload = function () { this.ready = !0, n.setDirtyCanvas(!0) }, e }, LGraphNode.prototype.captureInput = function (t) { if (this.graph && this.graph.list_of_graphcanvas) for (var e = this.graph.list_of_graphcanvas, n = 0; n < e.length; ++n) { var i = e[n]; (t || i.node_capturing_input == this) && (i.node_capturing_input = t ? this : null) } }, LGraphNode.prototype.collapse = function (t) { this.graph._version++, (!1 !== this.constructor.collapsable || t) && (this.flags.collapsed ? this.flags.collapsed = !1 : this.flags.collapsed = !0, this.setDirtyCanvas(!0, !0)) }, LGraphNode.prototype.pin = function (t) { this.graph._version++, void 0 === t ? this.flags.pinned = !this.flags.pinned : this.flags.pinned = t }, LGraphNode.prototype.localToScreen = function (t, e, n) { return [(t + this.pos[0]) * n.scale + n.offset[0], (e + this.pos[1]) * n.scale + n.offset[1]] }, global.LGraphGroup = LiteGraph.LGraphGroup = LGraphGroup, LGraphGroup.prototype._ctor = function (t) { this.title = t || "Group", this.font_size = 24, this.color = LGraphCanvas.node_colors.pale_blue ? LGraphCanvas.node_colors.pale_blue.groupcolor : "#AAA", this._bounding = new Float32Array([10, 10, 140, 80]), this._pos = this._bounding.subarray(0, 2), this._size = this._bounding.subarray(2, 4), this._nodes = [], this.graph = null, Object.defineProperty(this, "pos", { set: function (t) { t && !(t.length < 2) && (this._pos[0] = t[0], this._pos[1] = t[1]) }, get: function () { return this._pos }, enumerable: !0 }), Object.defineProperty(this, "size", { set: function (t) { t && !(t.length < 2) && (this._size[0] = Math.max(140, t[0]), this._size[1] = Math.max(80, t[1])) }, get: function () { return this._size }, enumerable: !0 }) }, LGraphGroup.prototype.configure = function (t) { this.title = t.title, this._bounding.set(t.bounding), this.color = t.color, this.font_size = t.font_size }, LGraphGroup.prototype.serialize = function () { var t = this._bounding; return { title: this.title, bounding: [Math.round(t[0]), Math.round(t[1]), Math.round(t[2]), Math.round(t[3])], color: this.color, font_size: this.font_size } }, LGraphGroup.prototype.move = function (t, e, n) { if (this._pos[0] += t, this._pos[1] += e, !n) for (var i = 0; i < this._nodes.length; ++i) { var o = this._nodes[i]; o.pos[0] += t, o.pos[1] += e } }, LGraphGroup.prototype.recomputeInsideNodes = function () { this._nodes.length = 0; for (var t = this.graph._nodes, e = new Float32Array(4), n = 0; n < t.length; ++n) { var i = t[n]; i.getBounding(e), overlapBounding(this._bounding, e) && this._nodes.push(i) } }, LGraphGroup.prototype.isPointInside = LGraphNode.prototype.isPointInside, LGraphGroup.prototype.setDirtyCanvas = LGraphNode.prototype.setDirtyCanvas, LiteGraph.DragAndScale = DragAndScale, DragAndScale.prototype.bindEvents = function (t) { this.last_mouse = new Float32Array(2), this._binded_mouse_callback = this.onMouse.bind(this), LiteGraph.pointerListenerAdd(t, "down", this._binded_mouse_callback), LiteGraph.pointerListenerAdd(t, "move", this._binded_mouse_callback), LiteGraph.pointerListenerAdd(t, "up", this._binded_mouse_callback), t.addEventListener("mousewheel", this._binded_mouse_callback, !1), t.addEventListener("wheel", this._binded_mouse_callback, !1) }, DragAndScale.prototype.computeVisibleArea = function (t) { if (!this.element) { this.visible_area[0] = this.visible_area[1] = this.visible_area[2] = this.visible_area[3] = 0; return } var e = this.element.width, n = this.element.height, i = -this.offset[0], o = -this.offset[1]; t && (i += t[0] / this.scale, o += t[1] / this.scale, e = t[2], n = t[3]); var s = i + e / this.scale, r = o + n / this.scale; this.visible_area[0] = i, this.visible_area[1] = o, this.visible_area[2] = s - i, this.visible_area[3] = r - o }, DragAndScale.prototype.onMouse = function (t) { if (this.enabled) { var e = this.element, n = e.getBoundingClientRect(), i = t.clientX - n.left, o = t.clientY - n.top; t.canvasx = i, t.canvasy = o, t.dragging = this.dragging; var s = !this.viewport || this.viewport && i >= this.viewport[0] && i < this.viewport[0] + this.viewport[2] && o >= this.viewport[1] && o < this.viewport[1] + this.viewport[3], r = !1; if (this.onmouse && (r = this.onmouse(t)), t.type == LiteGraph.pointerevents_method + "down" && s) this.dragging = !0, LiteGraph.pointerListenerRemove(e, "move", this._binded_mouse_callback), LiteGraph.pointerListenerAdd(document, "move", this._binded_mouse_callback), LiteGraph.pointerListenerAdd(document, "up", this._binded_mouse_callback); else if (t.type == LiteGraph.pointerevents_method + "move") { if (!r) { var a = i - this.last_mouse[0], l = o - this.last_mouse[1]; this.dragging && this.mouseDrag(a, l) } } else t.type == LiteGraph.pointerevents_method + "up" ? (this.dragging = !1, LiteGraph.pointerListenerRemove(document, "move", this._binded_mouse_callback), LiteGraph.pointerListenerRemove(document, "up", this._binded_mouse_callback), LiteGraph.pointerListenerAdd(e, "move", this._binded_mouse_callback)) : s && ("mousewheel" == t.type || "wheel" == t.type || "DOMMouseScroll" == t.type) && (t.eventType = "mousewheel", "wheel" == t.type ? t.wheel = -t.deltaY : t.wheel = null != t.wheelDeltaY ? t.wheelDeltaY : -60 * t.detail, t.delta = t.wheelDelta ? t.wheelDelta / 40 : t.deltaY ? -t.deltaY / 3 : 0, this.changeDeltaScale(1 + .05 * t.delta)); if (this.last_mouse[0] = i, this.last_mouse[1] = o, s) return t.preventDefault(), t.stopPropagation(), !1 } }, DragAndScale.prototype.toCanvasContext = function (t) { t.scale(this.scale, this.scale), t.translate(this.offset[0], this.offset[1]) }, DragAndScale.prototype.convertOffsetToCanvas = function (t) { return [(t[0] + this.offset[0]) * this.scale, (t[1] + this.offset[1]) * this.scale] }, DragAndScale.prototype.convertCanvasToOffset = function (t, e) { return (e = e || [0, 0])[0] = t[0] / this.scale - this.offset[0], e[1] = t[1] / this.scale - this.offset[1], e }, DragAndScale.prototype.mouseDrag = function (t, e) { this.offset[0] += t / this.scale, this.offset[1] += e / this.scale, this.onredraw && this.onredraw(this) }, DragAndScale.prototype.changeScale = function (t, e) { if (t < this.min_scale ? t = this.min_scale : t > this.max_scale && (t = this.max_scale), t != this.scale && this.element) { var n = this.element.getBoundingClientRect(); if (n) { e = e || [.5 * n.width, .5 * n.height]; var i = this.convertCanvasToOffset(e); this.scale = t, .01 > Math.abs(this.scale - 1) && (this.scale = 1); var o = this.convertCanvasToOffset(e), s = [o[0] - i[0], o[1] - i[1]]; this.offset[0] += s[0], this.offset[1] += s[1], this.onredraw && this.onredraw(this) } } }, DragAndScale.prototype.changeDeltaScale = function (t, e) { this.changeScale(this.scale * t, e) }, DragAndScale.prototype.reset = function () { this.scale = 1, this.offset[0] = 0, this.offset[1] = 0 }, global.LGraphCanvas = LiteGraph.LGraphCanvas = LGraphCanvas, LGraphCanvas.DEFAULT_BACKGROUND_IMAGE = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQBJREFUeNrs1rEKwjAUhlETUkj3vP9rdmr1Ysammk2w5wdxuLgcMHyptfawuZX4pJSWZTnfnu/lnIe/jNNxHHGNn//HNbbv+4dr6V+11uF527arU7+u63qfa/bnmh8sWLBgwYJlqRf8MEptXPBXJXa37BSl3ixYsGDBMliwFLyCV/DeLIMFCxYsWLBMwSt4Be/NggXLYMGCBUvBK3iNruC9WbBgwYJlsGApeAWv4L1ZBgsWLFiwYJmCV/AK3psFC5bBggULloJX8BpdwXuzYMGCBctgwVLwCl7Be7MMFixYsGDBsu8FH1FaSmExVfAxBa/gvVmwYMGCZbBg/W4vAQYA5tRF9QYlv/QAAAAASUVORK5CYII=", LGraphCanvas.link_type_colors = { "-1": LiteGraph.EVENT_LINK_COLOR, number: "#AAA", node: "#DCA" }, LGraphCanvas.gradients = {}, LGraphCanvas.prototype.clear = function () { this.frame = 0, this.last_draw_time = 0, this.render_time = 0, this.fps = 0, this.dragging_rectangle = null, this.selected_nodes = {}, this.selected_group = null, this.visible_nodes = [], this.node_dragged = null, this.node_over = null, this.node_capturing_input = null, this.connecting_node = null, this.highlighted_links = {}, this.dragging_canvas = !1, this.dirty_canvas = !0, this.dirty_bgcanvas = !0, this.dirty_area = null, this.node_in_panel = null, this.node_widget = null, this.last_mouse = [0, 0], this.last_mouseclick = 0, this.pointer_is_down = !1, this.pointer_is_double = !1, this.visible_area.set([0, 0, 0, 0]), this.onClear && this.onClear() }, LGraphCanvas.prototype.setGraph = function (t, e) { if (this.graph != t) { if (e || this.clear(), !t && this.graph) { this.graph.detachCanvas(this); return } t.attachCanvas(this), this._graph_stack && (this._graph_stack = null), this.setDirty(!0, !0) } }, LGraphCanvas.prototype.getTopGraph = function () { return this._graph_stack.length ? this._graph_stack[0] : this.graph }, LGraphCanvas.prototype.openSubgraph = function (t) { if (!t) throw "graph cannot be null"; if (this.graph == t) throw "graph cannot be the same"; this.clear(), this.graph && (this._graph_stack || (this._graph_stack = []), this._graph_stack.push(this.graph)), t.attachCanvas(this), this.checkPanels(), this.setDirty(!0, !0) }, LGraphCanvas.prototype.closeSubgraph = function () { if (this._graph_stack && 0 != this._graph_stack.length) { var t = this.graph._subgraph_node, e = this._graph_stack.pop(); this.selected_nodes = {}, this.highlighted_links = {}, e.attachCanvas(this), this.setDirty(!0, !0), t && (this.centerOnNode(t), this.selectNodes([t])), this.ds.offset = [0, 0], this.ds.scale = 1 } }, LGraphCanvas.prototype.getCurrentGraph = function () { return this.graph }, LGraphCanvas.prototype.setCanvas = function (t, e) { if (t && t.constructor === String && !(t = document.getElementById(t))) throw "Error creating LiteGraph canvas: Canvas not found"; if (t !== this.canvas) { if (t || !this.canvas || e || this.unbindEvents(), this.canvas = t, this.ds.element = t, t) { if (t.className += " lgraphcanvas", t.data = this, t.tabindex = "1", this.bgcanvas = null, this.bgcanvas || (this.bgcanvas = document.createElement("canvas"), this.bgcanvas.width = this.canvas.width, this.bgcanvas.height = this.canvas.height), null == t.getContext) { if ("canvas" != t.localName) throw "Element supplied for LGraphCanvas must be a <canvas> element, you passed a " + t.localName; throw "This browser doesn't support Canvas" } null == (this.ctx = t.getContext("2d")) && (t.webgl_enabled || console.warn("This canvas seems to be WebGL, enabling WebGL renderer"), this.enableWebGL()), e || this.bindEvents() } } }, LGraphCanvas.prototype._doNothing = function t(e) { return e.preventDefault(), !1 }, LGraphCanvas.prototype._doReturnTrue = function t(e) { return e.preventDefault(), !0 }, LGraphCanvas.prototype.bindEvents = function () { if (this._events_binded) { console.warn("LGraphCanvas: events already binded"); return } var t = this.canvas, e = this.getCanvasWindow().document; this._mousedown_callback = this.processMouseDown.bind(this), this._mousewheel_callback = this.processMouseWheel.bind(this), this._mousemove_callback = this.processMouseMove.bind(this), this._mouseup_callback = this.processMouseUp.bind(this), LiteGraph.pointerListenerAdd(t, "down", this._mousedown_callback, !0), t.addEventListener("mousewheel", this._mousewheel_callback, !1), LiteGraph.pointerListenerAdd(t, "up", this._mouseup_callback, !0), LiteGraph.pointerListenerAdd(t, "move", this._mousemove_callback), t.addEventListener("contextmenu", this._doNothing), t.addEventListener("DOMMouseScroll", this._mousewheel_callback, !1), this._key_callback = this.processKey.bind(this), t.setAttribute("tabindex", 1), t.addEventListener("keydown", this._key_callback, !0), e.addEventListener("keyup", this._key_callback, !0), this._ondrop_callback = this.processDrop.bind(this), t.addEventListener("dragover", this._doNothing, !1), t.addEventListener("dragend", this._doNothing, !1), t.addEventListener("drop", this._ondrop_callback, !1), t.addEventListener("dragenter", this._doReturnTrue, !1), this._events_binded = !0 }, LGraphCanvas.prototype.unbindEvents = function () { if (!this._events_binded) { console.warn("LGraphCanvas: no events binded"); return } var t = this.getCanvasWindow().document; LiteGraph.pointerListenerRemove(this.canvas, "move", this._mousedown_callback), LiteGraph.pointerListenerRemove(this.canvas, "up", this._mousedown_callback), LiteGraph.pointerListenerRemove(this.canvas, "down", this._mousedown_callback), this.canvas.removeEventListener("mousewheel", this._mousewheel_callback), this.canvas.removeEventListener("DOMMouseScroll", this._mousewheel_callback), this.canvas.removeEventListener("keydown", this._key_callback), t.removeEventListener("keyup", this._key_callback), this.canvas.removeEventListener("contextmenu", this._doNothing), this.canvas.removeEventListener("drop", this._ondrop_callback), this.canvas.removeEventListener("dragenter", this._doReturnTrue), this._mousedown_callback = null, this._mousewheel_callback = null, this._key_callback = null, this._ondrop_callback = null, this._events_binded = !1 }, LGraphCanvas.getFileExtension = function (t) { var e = t.indexOf("?"); -1 != e && (t = t.substr(0, e)); var n = t.lastIndexOf("."); return -1 == n ? "" : t.substr(n + 1).toLowerCase() }, LGraphCanvas.prototype.enableWebGL = function () { if ("undefined" == typeof GL) throw "litegl.js must be included to use a WebGL canvas"; if ("undefined" == typeof enableWebGLCanvas) throw "webglCanvas.js must be included to use this feature"; this.gl = this.ctx = enableWebGLCanvas(this.canvas), this.ctx.webgl = !0, this.bgcanvas = this.canvas, this.bgctx = this.gl, this.canvas.webgl_enabled = !0 }, LGraphCanvas.prototype.setDirty = function (t, e) { t && (this.dirty_canvas = !0), e && (this.dirty_bgcanvas = !0) }, LGraphCanvas.prototype.getCanvasWindow = function () { if (!this.canvas) return window; var t = this.canvas.ownerDocument; return t.defaultView || t.parentWindow }, LGraphCanvas.prototype.startRendering = function () { !this.is_rendering && (this.is_rendering = !0, t.call(this)); function t() { this.pause_rendering || this.draw(); var e = this.getCanvasWindow(); this.is_rendering && e.requestAnimationFrame(t.bind(this)) } }, LGraphCanvas.prototype.stopRendering = function () { this.is_rendering = !1 }, LGraphCanvas.prototype.blockClick = function () { this.block_click = !0, this.last_mouseclick = 0 }, LGraphCanvas.prototype.processMouseDown = function (t) { if (this.set_canvas_dirty_on_mouse_event && (this.dirty_canvas = !0), this.graph) { this.adjustMouseEvent(t); var e = this.getCanvasWindow(); e.document, LGraphCanvas.active_canvas = this; var n = this, i = t.clientX, o = t.clientY; this.ds.viewport = this.viewport; var s = !this.viewport || this.viewport && i >= this.viewport[0] && i < this.viewport[0] + this.viewport[2] && o >= this.viewport[1] && o < this.viewport[1] + this.viewport[3]; if (this.options.skip_events || (LiteGraph.pointerListenerRemove(this.canvas, "move", this._mousemove_callback), LiteGraph.pointerListenerAdd(e.document, "move", this._mousemove_callback, !0), LiteGraph.pointerListenerAdd(e.document, "up", this._mouseup_callback, !0)), s) { var r = this.graph.getNodeOnPos(t.canvasX, t.canvasY, this.visible_nodes, 5), a = !1, l = LiteGraph.getTime(), h = void 0 === t.isPrimary || !t.isPrimary, u = l - this.last_mouseclick < 300 && h; if (this.mouse[0] = t.clientX, this.mouse[1] = t.clientY, this.graph_mouse[0] = t.canvasX, this.graph_mouse[1] = t.canvasY, this.last_click_position = [this.mouse[0], this.mouse[1]], this.pointer_is_down && h ? this.pointer_is_double = !0 : this.pointer_is_double = !1, this.pointer_is_down = !0, this.canvas.focus(), LiteGraph.closeAllContextMenus(e), !this.onMouse || !0 != this.onMouse(t)) { if (1 != t.which || this.pointer_is_double) { if (2 == t.which) { if (LiteGraph.middle_click_slot_add_default_node) { if (r && this.allow_interaction && !a && !this.read_only && !this.connecting_node && !r.flags.collapsed && !this.live_mode) { var p = !1, c = !1, d = !1; if (r.outputs) for (var g = 0, f = r.outputs.length; g < f; ++g) { var v = r.outputs[g], $ = r.getConnectionPos(!1, g); if (isInsideRectangle(t.canvasX, t.canvasY, $[0] - 15, $[1] - 10, 30, 20)) { p = v, c = g, d = !0; break } } if (r.inputs) for (var g = 0, f = r.inputs.length; g < f; ++g) { var y = r.inputs[g], $ = r.getConnectionPos(!0, g); if (isInsideRectangle(t.canvasX, t.canvasY, $[0] - 15, $[1] - 10, 30, 20)) { p = y, c = g, d = !1; break } } if (p && !1 !== c) { var _ = .5 - (c + 1) / (d ? r.outputs.length : r.inputs.length), m = r.getBounding(), b = [d ? m[0] + m[2] : m[0], t.canvasY - 80]; this.createDefaultNodeForSlot({ nodeFrom: d ? r : null, slotFrom: d ? c : null, nodeTo: d ? null : r, slotTo: d ? null : c, position: b, nodeType: "AUTO", posAdd: [d ? 30 : -30, -(130 * _)], posSizeFix: [d ? 0 : -1, 0] }) } } } else !a && this.allow_dragcanvas && (this.dragging_canvas = !0) } else (3 == t.which || this.pointer_is_double) && this.allow_interaction && !a && !this.read_only && (r && (Object.keys(this.selected_nodes).length && (this.selected_nodes[r.id] || t.shiftKey || t.ctrlKey || t.metaKey) ? this.selected_nodes[r.id] || this.selectNodes([r], !0) : this.selectNodes([r])), this.processContextMenu(r, t)) } else { t.ctrlKey && (this.dragging_rectangle = new Float32Array(4), this.dragging_rectangle[0] = t.canvasX, this.dragging_rectangle[1] = t.canvasY, this.dragging_rectangle[2] = 1, this.dragging_rectangle[3] = 1, a = !0), LiteGraph.alt_drag_do_clone_nodes && t.altKey && r && this.allow_interaction && !a && !this.read_only && (cloned = r.clone()) && (cloned.pos[0] += 5, cloned.pos[1] += 5, this.graph.add(cloned, !1, { doCalcSize: !1 }), r = cloned, a = !0, k || (this.allow_dragnodes && (this.graph.beforeChange(), this.node_dragged = r), this.selected_nodes[r.id] || this.processNodeSelected(r, t))); var T = !1; if (r && (this.allow_interaction || r.flags.allow_interaction) && !a && !this.read_only) { if (this.live_mode || r.flags.pinned || this.bringToFront(r), this.allow_interaction && !this.connecting_node && !r.flags.collapsed && !this.live_mode) { if (!a && !1 !== r.resizable && isInsideRectangle(t.canvasX, t.canvasY, r.pos[0] + r.size[0] - 5, r.pos[1] + r.size[1] - 5, 10, 10)) this.graph.beforeChange(), this.resizing_node = r, this.canvas.style.cursor = "se-resize", a = !0; else { if (r.outputs) for (var g = 0, f = r.outputs.length; g < f; ++g) { var v = r.outputs[g], $ = r.getConnectionPos(!1, g); if (isInsideRectangle(t.canvasX, t.canvasY, $[0] - 15, $[1] - 10, 30, 20)) { this.connecting_node = r, this.connecting_output = v, this.connecting_output.slot_index = g, this.connecting_pos = r.getConnectionPos(!1, g), this.connecting_slot = g, LiteGraph.shift_click_do_break_link_from && t.shiftKey && r.disconnectOutput(g), u ? r.onOutputDblClick && r.onOutputDblClick(g, t) : r.onOutputClick && r.onOutputClick(g, t), a = !0; break } } if (r.inputs) for (var g = 0, f = r.inputs.length; g < f; ++g) { var y = r.inputs[g], $ = r.getConnectionPos(!0, g); if (isInsideRectangle(t.canvasX, t.canvasY, $[0] - 15, $[1] - 10, 30, 20)) { if (u ? r.onInputDblClick && r.onInputDblClick(g, t) : r.onInputClick && r.onInputClick(g, t), null !== y.link) { var E = this.graph.links[y.link]; LiteGraph.click_do_break_link_to && (r.disconnectInput(g), this.dirty_bgcanvas = !0, a = !0), (this.allow_reconnect_links || t.shiftKey) && (LiteGraph.click_do_break_link_to || r.disconnectInput(g), this.connecting_node = this.graph._nodes_by_id[E.origin_id], this.connecting_slot = E.origin_slot, this.connecting_output = this.connecting_node.outputs[this.connecting_slot], this.connecting_pos = this.connecting_node.getConnectionPos(!1, this.connecting_slot), this.dirty_bgcanvas = !0, a = !0) } a || (this.connecting_node = r, this.connecting_input = y, this.connecting_input.slot_index = g, this.connecting_pos = r.getConnectionPos(!0, g), this.connecting_slot = g, this.dirty_bgcanvas = !0, a = !0) } } } } if (!a) { var k = !1, C = [t.canvasX - r.pos[0], t.canvasY - r.pos[1]], w = this.processNodeWidgets(r, this.graph_mouse, t); if (w && (k = !0, this.node_widget = [r, w]), this.allow_interaction && u && this.selected_nodes[r.id] && (r.onDblClick && r.onDblClick(t, C, this), this.processNodeDblClicked(r), k = !0), r.onMouseDown && r.onMouseDown(t, C, this)) k = !0; else { if (r.subgraph && !r.skip_subgraph_button && !r.flags.collapsed && C[0] > r.size[0] - LiteGraph.NODE_TITLE_HEIGHT && C[1] < 0) { var n = this; setTimeout(function () { n.openSubgraph(r.subgraph) }, 10) } this.live_mode && (T = !0, k = !0) } k ? r.is_selected || this.processNodeSelected(r, t) : (this.allow_dragnodes && (this.graph.beforeChange(), this.node_dragged = r), this.processNodeSelected(r, t)), this.dirty_canvas = !0 } } else if (!a) { if (!this.read_only) for (var g = 0; g < this.visible_links.length; ++g) { var N = this.visible_links[g], O = N._pos; if (O && !(t.canvasX < O[0] - 4) && !(t.canvasX > O[0] + 4) && !(t.canvasY < O[1] - 4) && !(t.canvasY > O[1] + 4)) { this.showLinkMenu(N, t), this.over_link_center = null; break } } this.selected_group = this.graph.getGroupOnPos(t.canvasX, t.canvasY), this.selected_group_resizing = !1, this.selected_group && !this.read_only && (t.ctrlKey && (this.dragging_rectangle = null), distance([t.canvasX, t.canvasY], [this.selected_group.pos[0] + this.selected_group.size[0], this.selected_group.pos[1] + this.selected_group.size[1]]) * this.ds.scale < 10 ? this.selected_group_resizing = !0 : this.selected_group.recomputeInsideNodes()), u && !this.read_only && this.allow_searchbox && (this.showSearchBox(t), t.preventDefault(), t.stopPropagation()), T = !0 } !a && T && this.allow_dragcanvas && (this.dragging_canvas = !0) } return this.last_mouse[0] = t.clientX, this.last_mouse[1] = t.clientY, this.last_mouseclick = LiteGraph.getTime(), this.last_mouse_dragging = !0, this.graph.change(), e.document.activeElement && ("input" == e.document.activeElement.nodeName.toLowerCase() || "textarea" == e.document.activeElement.nodeName.toLowerCase()) || t.preventDefault(), t.stopPropagation(), this.onMouseDown && this.onMouseDown(t), !1 } } } }, LGraphCanvas.prototype.processMouseMove = function (t) { if (this.autoresize && this.resize(), this.set_canvas_dirty_on_mouse_event && (this.dirty_canvas = !0), this.graph) { LGraphCanvas.active_canvas = this, this.adjustMouseEvent(t); var e = [t.clientX, t.clientY]; this.mouse[0] = e[0], this.mouse[1] = e[1]; var n = [e[0] - this.last_mouse[0], e[1] - this.last_mouse[1]]; if (this.last_mouse = e, this.graph_mouse[0] = t.canvasX, this.graph_mouse[1] = t.canvasY, this.block_click) return t.preventDefault(), !1; t.dragging = this.last_mouse_dragging, this.node_widget && (this.processNodeWidgets(this.node_widget[0], this.graph_mouse, t, this.node_widget[1]), this.dirty_canvas = !0); var i = this.graph.getNodeOnPos(t.canvasX, t.canvasY, this.visible_nodes); if (this.dragging_rectangle) this.dragging_rectangle[2] = t.canvasX - this.dragging_rectangle[0], this.dragging_rectangle[3] = t.canvasY - this.dragging_rectangle[1], this.dirty_canvas = !0; else if (this.selected_group && !this.read_only) { if (this.selected_group_resizing) this.selected_group.size = [t.canvasX - this.selected_group.pos[0], t.canvasY - this.selected_group.pos[1]]; else { var o = n[0] / this.ds.scale, s = n[1] / this.ds.scale; this.selected_group.move(o, s, t.ctrlKey), this.selected_group._nodes.length && (this.dirty_canvas = !0) } this.dirty_bgcanvas = !0 } else if (this.dragging_canvas) this.ds.offset[0] += n[0] / this.ds.scale, this.ds.offset[1] += n[1] / this.ds.scale, this.dirty_canvas = !0, this.dirty_bgcanvas = !0; else if ((this.allow_interaction || i && i.flags.allow_interaction) && !this.read_only) { this.connecting_node && (this.dirty_canvas = !0); for (var r = 0, a = this.graph._nodes.length; r < a; ++r)this.graph._nodes[r].mouseOver && i != this.graph._nodes[r] && (this.graph._nodes[r].mouseOver = !1, this.node_over && this.node_over.onMouseLeave && this.node_over.onMouseLeave(t), this.node_over = null, this.dirty_canvas = !0); if (i) { if (i.redraw_on_mouse && (this.dirty_canvas = !0), !i.mouseOver && (i.mouseOver = !0, this.node_over = i, this.dirty_canvas = !0, i.onMouseEnter && i.onMouseEnter(t)), i.onMouseMove && i.onMouseMove(t, [t.canvasX - i.pos[0], t.canvasY - i.pos[1]], this), this.connecting_node) { if (this.connecting_output) { var l = this._highlight_input || [0, 0]; if (this.isOverNodeBox(i, t.canvasX, t.canvasY)); else { var h = this.isOverNodeInput(i, t.canvasX, t.canvasY, l); if (-1 != h && i.inputs[h]) { var u = i.inputs[h].type; LiteGraph.isValidConnection(this.connecting_output.type, u) && (this._highlight_input = l, this._highlight_input_slot = i.inputs[h]) } else this._highlight_input = null, this._highlight_input_slot = null } } else if (this.connecting_input) { var l = this._highlight_output || [0, 0]; if (this.isOverNodeBox(i, t.canvasX, t.canvasY)); else { var h = this.isOverNodeOutput(i, t.canvasX, t.canvasY, l); if (-1 != h && i.outputs[h]) { var u = i.outputs[h].type; LiteGraph.isValidConnection(this.connecting_input.type, u) && (this._highlight_output = l) } else this._highlight_output = null } } } this.canvas && (isInsideRectangle(t.canvasX, t.canvasY, i.pos[0] + i.size[0] - 5, i.pos[1] + i.size[1] - 5, 5, 5) ? this.canvas.style.cursor = "se-resize" : this.canvas.style.cursor = "crosshair") } else { for (var p = null, r = 0; r < this.visible_links.length; ++r) { var c = this.visible_links[r], d = c._pos; if (d && !(t.canvasX < d[0] - 4) && !(t.canvasX > d[0] + 4) && !(t.canvasY < d[1] - 4) && !(t.canvasY > d[1] + 4)) { p = c; break } } p != this.over_link_center && (this.over_link_center = p, this.dirty_canvas = !0), this.canvas && (this.canvas.style.cursor = "") } if (this.node_capturing_input && this.node_capturing_input != i && this.node_capturing_input.onMouseMove && this.node_capturing_input.onMouseMove(t, [t.canvasX - this.node_capturing_input.pos[0], t.canvasY - this.node_capturing_input.pos[1]], this), this.node_dragged && !this.live_mode) { for (var r in this.selected_nodes) { var g = this.selected_nodes[r]; g.pos[0] += n[0] / this.ds.scale, g.pos[1] += n[1] / this.ds.scale, g.is_selected || this.processNodeSelected(g, t) } this.dirty_canvas = !0, this.dirty_bgcanvas = !0 } if (this.resizing_node && !this.live_mode) { var f = [t.canvasX - this.resizing_node.pos[0], t.canvasY - this.resizing_node.pos[1]], v = this.resizing_node.computeSize(); f[0] = Math.max(v[0], f[0]), f[1] = Math.max(v[1], f[1]), this.resizing_node.setSize(f), this.canvas.style.cursor = "se-resize", this.dirty_canvas = !0, this.dirty_bgcanvas = !0 } } return t.preventDefault(), !1 } }, LGraphCanvas.prototype.processMouseUp = function (t) { var e = void 0 === t.isPrimary || t.isPrimary; if (!e) return !1; if (this.set_canvas_dirty_on_mouse_event && (this.dirty_canvas = !0), this.graph) { var n, i = this.getCanvasWindow().document; LGraphCanvas.active_canvas = this, this.options.skip_events || (LiteGraph.pointerListenerRemove(i, "move", this._mousemove_callback, !0), LiteGraph.pointerListenerAdd(this.canvas, "move", this._mousemove_callback, !0), LiteGraph.pointerListenerRemove(i, "up", this._mouseup_callback, !0)), this.adjustMouseEvent(t); var o = LiteGraph.getTime(); if (t.click_time = o - this.last_mouseclick, this.last_mouse_dragging = !1, this.last_click_position = null, this.block_click && (this.block_click = !1), 1 == t.which) { if (this.node_widget && this.processNodeWidgets(this.node_widget[0], this.graph_mouse, t), this.node_widget = null, this.selected_group) { var s = this.selected_group.pos[0] - Math.round(this.selected_group.pos[0]), r = this.selected_group.pos[1] - Math.round(this.selected_group.pos[1]); this.selected_group.move(s, r, t.ctrlKey), this.selected_group.pos[0] = Math.round(this.selected_group.pos[0]), this.selected_group.pos[1] = Math.round(this.selected_group.pos[1]), this.selected_group._nodes.length && (this.dirty_canvas = !0), this.selected_group = null } this.selected_group_resizing = !1; var a = this.graph.getNodeOnPos(t.canvasX, t.canvasY, this.visible_nodes); if (this.dragging_rectangle) { if (this.graph) { var l = this.graph._nodes, h = new Float32Array(4), u = Math.abs(this.dragging_rectangle[2]), p = Math.abs(this.dragging_rectangle[3]), c = this.dragging_rectangle[2] < 0 ? this.dragging_rectangle[0] - u : this.dragging_rectangle[0], d = this.dragging_rectangle[3] < 0 ? this.dragging_rectangle[1] - p : this.dragging_rectangle[1]; if (this.dragging_rectangle[0] = c, this.dragging_rectangle[1] = d, this.dragging_rectangle[2] = u, this.dragging_rectangle[3] = p, !a || u > 10 && p > 10) { for (var g = [], f = 0; f < l.length; ++f) { var v = l[f]; v.getBounding(h), overlapBounding(this.dragging_rectangle, h) && g.push(v) } g.length && this.selectNodes(g, t.shiftKey) } else this.selectNodes([a], t.shiftKey || t.ctrlKey) } this.dragging_rectangle = null } else if (this.connecting_node) { this.dirty_canvas = !0, this.dirty_bgcanvas = !0; var $ = (this.connecting_output || this.connecting_input).type; if (a) { if (this.connecting_output) { var y = this.isOverNodeInput(a, t.canvasX, t.canvasY); -1 != y ? this.connecting_node.connect(this.connecting_slot, a, y) : this.connecting_node.connectByType(this.connecting_slot, a, $) } else if (this.connecting_input) { var y = this.isOverNodeOutput(a, t.canvasX, t.canvasY); -1 != y ? a.connect(y, this.connecting_node, this.connecting_slot) : this.connecting_node.connectByTypeOutput(this.connecting_slot, a, $) } } else LiteGraph.release_link_on_empty_shows_menu && (t.shiftKey && this.allow_searchbox ? this.connecting_output ? this.showSearchBox(t, { node_from: this.connecting_node, slot_from: this.connecting_output, type_filter_in: this.connecting_output.type }) : this.connecting_input && this.showSearchBox(t, { node_to: this.connecting_node, slot_from: this.connecting_input, type_filter_out: this.connecting_input.type }) : this.connecting_output ? this.showConnectionMenu({ nodeFrom: this.connecting_node, slotFrom: this.connecting_output, e: t }) : this.connecting_input && this.showConnectionMenu({ nodeTo: this.connecting_node, slotTo: this.connecting_input, e: t })); this.connecting_output = null, this.connecting_input = null, this.connecting_pos = null, this.connecting_node = null, this.connecting_slot = -1 } else if (this.resizing_node) this.dirty_canvas = !0, this.dirty_bgcanvas = !0, this.graph.afterChange(this.resizing_node), this.resizing_node = null; else if (this.node_dragged) { var a = this.node_dragged; a && t.click_time < 300 && isInsideRectangle(t.canvasX, t.canvasY, a.pos[0], a.pos[1] - LiteGraph.NODE_TITLE_HEIGHT, LiteGraph.NODE_TITLE_HEIGHT, LiteGraph.NODE_TITLE_HEIGHT) && a.collapse(), this.dirty_canvas = !0, this.dirty_bgcanvas = !0, this.node_dragged.pos[0] = Math.round(this.node_dragged.pos[0]), this.node_dragged.pos[1] = Math.round(this.node_dragged.pos[1]), (this.graph.config.align_to_grid || this.align_to_grid) && this.node_dragged.alignToGrid(), this.onNodeMoved && this.onNodeMoved(this.node_dragged), this.graph.afterChange(this.node_dragged), this.node_dragged = null } else { var a = this.graph.getNodeOnPos(t.canvasX, t.canvasY, this.visible_nodes); !a && t.click_time < 300 && this.deselectAllNodes(), this.dirty_canvas = !0, this.dragging_canvas = !1, this.node_over && this.node_over.onMouseUp && this.node_over.onMouseUp(t, [t.canvasX - this.node_over.pos[0], t.canvasY - this.node_over.pos[1]], this), this.node_capturing_input && this.node_capturing_input.onMouseUp && this.node_capturing_input.onMouseUp(t, [t.canvasX - this.node_capturing_input.pos[0], t.canvasY - this.node_capturing_input.pos[1]]) } } else 2 == t.which ? (this.dirty_canvas = !0, this.dragging_canvas = !1) : 3 == t.which && (this.dirty_canvas = !0, this.dragging_canvas = !1); return e && (this.pointer_is_down = !1, this.pointer_is_double = !1), this.graph.change(), t.stopPropagation(), t.preventDefault(), !1 } }, LGraphCanvas.prototype.processMouseWheel = function (t) { if (this.graph && this.allow_dragcanvas) { var e = null != t.wheelDeltaY ? t.wheelDeltaY : -60 * t.detail; this.adjustMouseEvent(t); var n, i = t.clientX, o = t.clientY; if (!this.viewport || this.viewport && i >= this.viewport[0] && i < this.viewport[0] + this.viewport[2] && o >= this.viewport[1] && o < this.viewport[1] + this.viewport[3]) { var s = this.ds.scale; return e > 0 ? s *= 1.1 : e < 0 && (s *= 1 / 1.1), this.ds.changeScale(s, [t.clientX, t.clientY]), this.graph.change(), t.preventDefault(), !1 } } }, LGraphCanvas.prototype.isOverNodeBox = function (t, e, n) { var i = LiteGraph.NODE_TITLE_HEIGHT; return !!isInsideRectangle(e, n, t.pos[0] + 2, t.pos[1] + 2 - i, i - 4, i - 4) }, LGraphCanvas.prototype.isOverNodeInput = function (t, e, n, i) { if (t.inputs) for (var o = 0, s = t.inputs.length; o < s; ++o) { t.inputs[o]; var r = t.getConnectionPos(!0, o), a = !1; if (a = t.horizontal ? isInsideRectangle(e, n, r[0] - 5, r[1] - 10, 10, 20) : isInsideRectangle(e, n, r[0] - 10, r[1] - 5, 40, 10)) return i && (i[0] = r[0], i[1] = r[1]), o } return -1 }, LGraphCanvas.prototype.isOverNodeOutput = function (t, e, n, i) { if (t.outputs) for (var o = 0, s = t.outputs.length; o < s; ++o) { t.outputs[o]; var r = t.getConnectionPos(!1, o), a = !1; if (a = t.horizontal ? isInsideRectangle(e, n, r[0] - 5, r[1] - 10, 10, 20) : isInsideRectangle(e, n, r[0] - 10, r[1] - 5, 40, 10)) return i && (i[0] = r[0], i[1] = r[1]), o } return -1 }, LGraphCanvas.prototype.processKey = function (t) { if (this.graph) { var e = !1; if ("input" != t.target.localName) { if ("keydown" == t.type) { if (32 == t.keyCode && (this.dragging_canvas = !0, e = !0), 27 == t.keyCode && (this.node_panel && this.node_panel.close(), this.options_panel && this.options_panel.close(), e = !0), 65 == t.keyCode && t.ctrlKey && (this.selectNodes(), e = !0), 67 === t.keyCode && (t.metaKey || t.ctrlKey) && !t.shiftKey && this.selected_nodes && (this.copyToClipboard(), e = !0), 86 === t.keyCode && (t.metaKey || t.ctrlKey) && this.pasteFromClipboard(t.shiftKey), (46 == t.keyCode || 8 == t.keyCode) && "input" != t.target.localName && "textarea" != t.target.localName && (this.deleteSelectedNodes(), e = !0), this.selected_nodes) for (var n in this.selected_nodes) this.selected_nodes[n].onKeyDown && this.selected_nodes[n].onKeyDown(t) } else if ("keyup" == t.type && (32 == t.keyCode && (this.dragging_canvas = !1), this.selected_nodes)) for (var n in this.selected_nodes) this.selected_nodes[n].onKeyUp && this.selected_nodes[n].onKeyUp(t); if (this.graph.change(), e) return t.preventDefault(), t.stopImmediatePropagation(), !1 } } }, LGraphCanvas.prototype.copyToClipboard = function () { var t = { nodes: [], links: [] }, e = 0, n = []; for (var i in this.selected_nodes) { var o = this.selected_nodes[i]; !1 !== o.clonable && (o._relative_id = e, n.push(o), e += 1) } for (var i = 0; i < n.length; ++i) { var o = n[i]; if (!1 !== o.clonable) { var s = o.clone(); if (!s) { console.warn("node type not found: " + o.type); continue } if (t.nodes.push(s.serialize()), o.inputs && o.inputs.length) for (var r = 0; r < o.inputs.length; ++r) { var a = o.inputs[r]; if (a && null != a.link) { var l = this.graph.links[a.link]; if (l) { var h = this.graph.getNodeById(l.origin_id); h && t.links.push([h._relative_id, l.origin_slot, o._relative_id, l.target_slot, h.id]) } } } } } localStorage.setItem("litegrapheditor_clipboard", JSON.stringify(t)) }, LGraphCanvas.prototype.pasteFromClipboard = function (t = !1) { if (LiteGraph.ctrl_shift_v_paste_connect_unselected_outputs || !t) { var e = localStorage.getItem("litegrapheditor_clipboard"); if (e) { this.graph.beforeChange(); for (var n = JSON.parse(e), i = !1, o = !1, s = 0; s < n.nodes.length; ++s)i ? (i[0] > n.nodes[s].pos[0] && (i[0] = n.nodes[s].pos[0], o[0] = s), i[1] > n.nodes[s].pos[1] && (i[1] = n.nodes[s].pos[1], o[1] = s)) : (i = [n.nodes[s].pos[0], n.nodes[s].pos[1]], o = [s, s]); for (var r = [], s = 0; s < n.nodes.length; ++s) { var a = n.nodes[s], l = LiteGraph.createNode(a.type); l && (l.configure(a), l.pos[0] += this.graph_mouse[0] - i[0], l.pos[1] += this.graph_mouse[1] - i[1], this.graph.add(l, { doProcessChange: !1 }), r.push(l)) } for (var s = 0; s < n.links.length; ++s) { var h, u = n.links[s], p = u[0]; if (null != p) h = r[p]; else if (LiteGraph.ctrl_shift_v_paste_connect_unselected_outputs && t) { var c = u[4]; c && (h = this.graph.getNodeById(c)) } var d = r[u[2]]; h && d ? h.connect(u[1], d, u[3]) : console.warn("Warning, nodes missing on pasting") } this.selectNodes(r), this.graph.afterChange() } } }, LGraphCanvas.prototype.processDrop = function (t) { t.preventDefault(), this.adjustMouseEvent(t); var e = t.clientX, n = t.clientY; if (!this.viewport || this.viewport && e >= this.viewport[0] && e < this.viewport[0] + this.viewport[2] && n >= this.viewport[1] && n < this.viewport[1] + this.viewport[3]) { var i = [t.canvasX, t.canvasY], o = this.graph ? this.graph.getNodeOnPos(i[0], i[1]) : null; if (!o) { var s = null; this.onDropItem && (s = this.onDropItem(event)), s || this.checkDropItem(t); return } if (o.onDropFile || o.onDropData) { var r = t.dataTransfer.files; if (r && r.length) for (var a = 0; a < r.length; a++) { var l = t.dataTransfer.files[0], h = l.name; if (LGraphCanvas.getFileExtension(h), o.onDropFile && o.onDropFile(l), o.onDropData) { var u = new FileReader; u.onload = function (t) { var e = t.target.result; o.onDropData(e, h, l) }; var p = l.type.split("/")[0]; "text" == p || "" == p ? u.readAsText(l) : "image" == p ? u.readAsDataURL(l) : u.readAsArrayBuffer(l) } } } return !!(o.onDropItem && o.onDropItem(event)) || !!this.onDropItem && this.onDropItem(event) } }, LGraphCanvas.prototype.checkDropItem = function (t) { if (t.dataTransfer.files.length) { var e = t.dataTransfer.files[0], n = LGraphCanvas.getFileExtension(e.name).toLowerCase(), i = LiteGraph.node_types_by_file_extension[n]; if (i) { this.graph.beforeChange(); var o = LiteGraph.createNode(i.type); o.pos = [t.canvasX, t.canvasY], this.graph.add(o), o.onDropFile && o.onDropFile(e), this.graph.afterChange() } } }, LGraphCanvas.prototype.processNodeDblClicked = function (t) { this.onShowNodePanel ? this.onShowNodePanel(t) : this.showShowNodePanel(t), this.onNodeDblClicked && this.onNodeDblClicked(t), this.setDirty(!0) }, LGraphCanvas.prototype.processNodeSelected = function (t, e) { this.selectNode(t, e && (e.shiftKey || e.ctrlKey || this.multi_select)), this.onNodeSelected && this.onNodeSelected(t) }, LGraphCanvas.prototype.selectNode = function (t, e) { null == t ? this.deselectAllNodes() : this.selectNodes([t], e) }, LGraphCanvas.prototype.selectNodes = function (t, e) { for (var n in e || this.deselectAllNodes(), "string" == typeof (t = t || this.graph._nodes) && (t = [t]), t) { var i = t[n]; if (i.is_selected) { this.deselectNode(i); continue } if (!i.is_selected && i.onSelected && i.onSelected(), i.is_selected = !0, this.selected_nodes[i.id] = i, i.inputs) for (var o = 0; o < i.inputs.length; ++o)this.highlighted_links[i.inputs[o].link] = !0; if (i.outputs) for (var o = 0; o < i.outputs.length; ++o) { var s = i.outputs[o]; if (s.links) for (var r = 0; r < s.links.length; ++r)this.highlighted_links[s.links[r]] = !0 } } this.onSelectionChange && this.onSelectionChange(this.selected_nodes), this.setDirty(!0) }, LGraphCanvas.prototype.deselectNode = function (t) { if (t.is_selected) { if (t.onDeselected && t.onDeselected(), t.is_selected = !1, this.onNodeDeselected && this.onNodeDeselected(t), t.inputs) for (var e = 0; e < t.inputs.length; ++e)delete this.highlighted_links[t.inputs[e].link]; if (t.outputs) for (var e = 0; e < t.outputs.length; ++e) { var n = t.outputs[e]; if (n.links) for (var i = 0; i < n.links.length; ++i)delete this.highlighted_links[n.links[i]] } } }, LGraphCanvas.prototype.deselectAllNodes = function () { if (this.graph) { for (var t = this.graph._nodes, e = 0, n = t.length; e < n; ++e) { var i = t[e]; i.is_selected && (i.onDeselected && i.onDeselected(), i.is_selected = !1, this.onNodeDeselected && this.onNodeDeselected(i)) } this.selected_nodes = {}, this.current_node = null, this.highlighted_links = {}, this.onSelectionChange && this.onSelectionChange(this.selected_nodes), this.setDirty(!0) } }, LGraphCanvas.prototype.deleteSelectedNodes = function () { for (var t in this.graph.beforeChange(), this.selected_nodes) { var e = this.selected_nodes[t]; if (!e.block_delete) { if (e.inputs && e.inputs.length && e.outputs && e.outputs.length && LiteGraph.isValidConnection(e.inputs[0].type, e.outputs[0].type) && e.inputs[0].link && e.outputs[0].links && e.outputs[0].links.length) { var n = e.graph.links[e.inputs[0].link], i = e.graph.links[e.outputs[0].links[0]], o = e.getInputNode(0), s = e.getOutputNodes(0)[0]; o && s && o.connect(n.origin_slot, s, i.target_slot) } this.graph.remove(e), this.onNodeDeselected && this.onNodeDeselected(e) } } this.selected_nodes = {}, this.current_node = null, this.highlighted_links = {}, this.setDirty(!0), this.graph.afterChange() }, LGraphCanvas.prototype.centerOnNode = function (t) { this.ds.offset[0] = -t.pos[0] - .5 * t.size[0] + .5 * this.canvas.width / this.ds.scale, this.ds.offset[1] = -t.pos[1] - .5 * t.size[1] + .5 * this.canvas.height / this.ds.scale, this.setDirty(!0, !0) }, LGraphCanvas.prototype.adjustMouseEvent = function (t) { var e = 0, n = 0; if (this.canvas) { var i = this.canvas.getBoundingClientRect(); e = t.clientX - i.left, n = t.clientY - i.top } else e = t.clientX, n = t.clientY; this.last_mouse_position[0] = e, this.last_mouse_position[1] = n, t.canvasX = e / this.ds.scale - this.ds.offset[0], t.canvasY = n / this.ds.scale - this.ds.offset[1] }, LGraphCanvas.prototype.setZoom = function (t, e) { this.ds.changeScale(t, e), this.dirty_canvas = !0, this.dirty_bgcanvas = !0 }, LGraphCanvas.prototype.convertOffsetToCanvas = function (t, e) { return this.ds.convertOffsetToCanvas(t, e) }, LGraphCanvas.prototype.convertCanvasToOffset = function (t, e) { return this.ds.convertCanvasToOffset(t, e) }, LGraphCanvas.prototype.convertEventToCanvasOffset = function (t) { var e = this.canvas.getBoundingClientRect(); return this.convertCanvasToOffset([t.clientX - e.left, t.clientY - e.top]) }, LGraphCanvas.prototype.bringToFront = function (t) { var e = this.graph._nodes.indexOf(t); -1 != e && (this.graph._nodes.splice(e, 1), this.graph._nodes.push(t)) }, LGraphCanvas.prototype.sendToBack = function (t) { var e = this.graph._nodes.indexOf(t); -1 != e && (this.graph._nodes.splice(e, 1), this.graph._nodes.unshift(t)) }; var temp = new Float32Array(4); LGraphCanvas.prototype.computeVisibleNodes = function (t, e) { var n = e || []; n.length = 0, t = t || this.graph._nodes; for (var i = 0, o = t.length; i < o; ++i) { var s = t[i]; (!this.live_mode || s.onDrawBackground || s.onDrawForeground) && overlapBounding(this.visible_area, s.getBounding(temp, !0)) && n.push(s) } return n }, LGraphCanvas.prototype.draw = function (t, e) { if (this.canvas && 0 != this.canvas.width && 0 != this.canvas.height) { var n = LiteGraph.getTime(); this.render_time = (n - this.last_draw_time) * .001, this.last_draw_time = n, this.graph && this.ds.computeVisibleArea(this.viewport), (this.dirty_bgcanvas || e || this.always_render_background || this.graph && this.graph._last_trigger_time && n - this.graph._last_trigger_time < 1e3) && this.drawBackCanvas(), (this.dirty_canvas || t) && this.drawFrontCanvas(), this.fps = this.render_time ? 1 / this.render_time : 0, this.frame += 1 } }, LGraphCanvas.prototype.drawFrontCanvas = function () { this.dirty_canvas = !1, this.ctx || (this.ctx = this.bgcanvas.getContext("2d")); var t = this.ctx; if (t) { var e = this.canvas; t.start2D && !this.viewport && (t.start2D(), t.restore(), t.setTransform(1, 0, 0, 1, 0, 0)); var n = this.viewport || this.dirty_area; if (n && (t.save(), t.beginPath(), t.rect(n[0], n[1], n[2], n[3]), t.clip()), this.clear_background && (n ? t.clearRect(n[0], n[1], n[2], n[3]) : t.clearRect(0, 0, e.width, e.height)), this.bgcanvas == this.canvas ? this.drawBackCanvas() : t.drawImage(this.bgcanvas, 0, 0), this.onRender && this.onRender(e, t), this.show_info && this.renderInfo(t, n ? n[0] : 0, n ? n[1] : 0), this.graph) { t.save(), this.ds.toCanvasContext(t); for (var i = 0, o = this.computeVisibleNodes(null, this.visible_nodes), s = 0; s < o.length; ++s) { var r = o[s]; t.save(), t.translate(r.pos[0], r.pos[1]), this.drawNode(r, t), i += 1, t.restore() } if (this.render_execution_order && this.drawExecutionOrder(t), this.graph.config.links_ontop && !this.live_mode && this.drawConnections(t), null != this.connecting_pos) { t.lineWidth = this.connections_width; var a = null, l = this.connecting_output || this.connecting_input, h = l.type, u = l.dir; null == u && (u = this.connecting_output ? this.connecting_node.horizontal ? LiteGraph.DOWN : LiteGraph.RIGHT : this.connecting_node.horizontal ? LiteGraph.UP : LiteGraph.LEFT); var p = l.shape; if (a = h === LiteGraph.EVENT ? LiteGraph.EVENT_LINK_COLOR : LiteGraph.CONNECTING_LINK_COLOR, this.renderLink(t, this.connecting_pos, [this.graph_mouse[0], this.graph_mouse[1]], null, !1, null, a, u, LiteGraph.CENTER), t.beginPath(), h === LiteGraph.EVENT || p === LiteGraph.BOX_SHAPE ? (t.rect(this.connecting_pos[0] - 6 + .5, this.connecting_pos[1] - 5 + .5, 14, 10), t.fill(), t.beginPath(), t.rect(this.graph_mouse[0] - 6 + .5, this.graph_mouse[1] - 5 + .5, 14, 10)) : p === LiteGraph.ARROW_SHAPE ? (t.moveTo(this.connecting_pos[0] + 8, this.connecting_pos[1] + .5), t.lineTo(this.connecting_pos[0] - 4, this.connecting_pos[1] + 6 + .5), t.lineTo(this.connecting_pos[0] - 4, this.connecting_pos[1] - 6 + .5), t.closePath()) : (t.arc(this.connecting_pos[0], this.connecting_pos[1], 4, 0, 2 * Math.PI), t.fill(), t.beginPath(), t.arc(this.graph_mouse[0], this.graph_mouse[1], 4, 0, 2 * Math.PI)), t.fill(), t.fillStyle = "#ffcc00", this._highlight_input) { t.beginPath(); var c = this._highlight_input_slot.shape; c === LiteGraph.ARROW_SHAPE ? (t.moveTo(this._highlight_input[0] + 8, this._highlight_input[1] + .5), t.lineTo(this._highlight_input[0] - 4, this._highlight_input[1] + 6 + .5), t.lineTo(this._highlight_input[0] - 4, this._highlight_input[1] - 6 + .5), t.closePath()) : t.arc(this._highlight_input[0], this._highlight_input[1], 6, 0, 2 * Math.PI), t.fill() } this._highlight_output && (t.beginPath(), c === LiteGraph.ARROW_SHAPE ? (t.moveTo(this._highlight_output[0] + 8, this._highlight_output[1] + .5), t.lineTo(this._highlight_output[0] - 4, this._highlight_output[1] + 6 + .5), t.lineTo(this._highlight_output[0] - 4, this._highlight_output[1] - 6 + .5), t.closePath()) : t.arc(this._highlight_output[0], this._highlight_output[1], 6, 0, 2 * Math.PI), t.fill()) } this.dragging_rectangle && (t.strokeStyle = "#FFF", t.strokeRect(this.dragging_rectangle[0], this.dragging_rectangle[1], this.dragging_rectangle[2], this.dragging_rectangle[3])), this.over_link_center && this.render_link_tooltip ? this.drawLinkTooltip(t, this.over_link_center) : this.onDrawLinkTooltip && this.onDrawLinkTooltip(t, null), this.onDrawForeground && this.onDrawForeground(t, this.visible_rect), t.restore() } this._graph_stack && this._graph_stack.length && this.drawSubgraphPanel(t), this.onDrawOverlay && this.onDrawOverlay(t), n && t.restore(), t.finish2D && t.finish2D() } }, LGraphCanvas.prototype.drawSubgraphPanel = function (t) { var e = this.graph, n = e._subgraph_node; if (!n) { console.warn("subgraph without subnode"); return } this.drawSubgraphPanelLeft(e, n, t), this.drawSubgraphPanelRight(e, n, t) }, LGraphCanvas.prototype.drawSubgraphPanelLeft = function (t, e, n) { var i = e.inputs ? e.inputs.length : 0, o = 200, s = Math.floor(1.6 * LiteGraph.NODE_SLOT_HEIGHT); if (n.fillStyle = "#111", n.globalAlpha = .8, n.beginPath(), n.roundRect(10, 10, o, (i + 1) * s + 50, [8]), n.fill(), n.globalAlpha = 1, n.fillStyle = "#888", n.font = "14px Arial", n.textAlign = "left", n.fillText("Graph Inputs", 20, 34), this.drawButton(o - 20, 20, 20, 20, "X", "#151515")) { this.closeSubgraph(); return } var r = 50; if (n.font = "14px Arial", e.inputs) for (var a = 0; a < e.inputs.length; ++a) { var l = e.inputs[a]; if (!l.not_subgraph_input) { if (this.drawButton(20, r + 2, o - 20, s - 2)) { var h = e.constructor.input_node_type || "graph/input"; this.graph.beforeChange(); var u = LiteGraph.createNode(h); u ? (t.add(u), this.block_click = !1, this.last_click_position = null, this.selectNodes([u]), this.node_dragged = u, this.dragging_canvas = !1, u.setProperty("name", l.name), u.setProperty("type", l.type), this.node_dragged.pos[0] = this.graph_mouse[0] - 5, this.node_dragged.pos[1] = this.graph_mouse[1] - 5, this.graph.afterChange()) : console.error("graph input node not found:", h) } n.fillStyle = "#9C9", n.beginPath(), n.arc(o - 16, r + .5 * s, 5, 0, 2 * Math.PI), n.fill(), n.fillStyle = "#AAA", n.fillText(l.name, 30, r + .75 * s), n.fillStyle = "#777", n.fillText(l.type, 130, r + .75 * s), r += s } } this.drawButton(20, r + 2, o - 20, s - 2, "+", "#151515", "#222") && this.showSubgraphPropertiesDialog(e) }, LGraphCanvas.prototype.drawSubgraphPanelRight = function (t, e, n) { var i = e.outputs ? e.outputs.length : 0, o = this.bgcanvas.width, s = 200, r = Math.floor(1.6 * LiteGraph.NODE_SLOT_HEIGHT); n.fillStyle = "#111", n.globalAlpha = .8, n.beginPath(), n.roundRect(o - s - 10, 10, s, (i + 1) * r + 50, [8]), n.fill(), n.globalAlpha = 1, n.fillStyle = "#888", n.font = "14px Arial", n.textAlign = "left"; var a = "Graph Outputs", l = n.measureText(a).width; if (n.fillText(a, o - l - 20, 34), this.drawButton(o - s, 20, 20, 20, "X", "#151515")) { this.closeSubgraph(); return } var h = 50; if (n.font = "14px Arial", e.outputs) for (var u = 0; u < e.outputs.length; ++u) { var p = e.outputs[u]; if (!p.not_subgraph_input) { if (this.drawButton(o - s, h + 2, s - 20, r - 2)) { var c = e.constructor.output_node_type || "graph/output"; this.graph.beforeChange(); var d = LiteGraph.createNode(c); d ? (t.add(d), this.block_click = !1, this.last_click_position = null, this.selectNodes([d]), this.node_dragged = d, this.dragging_canvas = !1, d.setProperty("name", p.name), d.setProperty("type", p.type), this.node_dragged.pos[0] = this.graph_mouse[0] - 5, this.node_dragged.pos[1] = this.graph_mouse[1] - 5, this.graph.afterChange()) : console.error("graph input node not found:", c) } n.fillStyle = "#9C9", n.beginPath(), n.arc(o - s + 16, h + .5 * r, 5, 0, 2 * Math.PI), n.fill(), n.fillStyle = "#AAA", n.fillText(p.name, o - s + 30, h + .75 * r), n.fillStyle = "#777", n.fillText(p.type, o - s + 130, h + .75 * r), h += r } } this.drawButton(o - s, h + 2, s - 20, r - 2, "+", "#151515", "#222") && this.showSubgraphPropertiesDialogRight(e) }, LGraphCanvas.prototype.drawButton = function (t, e, n, i, o, s, r, a) { var l = this.ctx; s = s || LiteGraph.NODE_DEFAULT_COLOR, r = r || "#555", a = a || LiteGraph.NODE_TEXT_COLOR; var h = this.ds.convertOffsetToCanvas(this.graph_mouse), u = LiteGraph.isInsideRectangle(h[0], h[1], t, e, n, i); if (h = this.last_click_position ? [this.last_click_position[0], this.last_click_position[1]] : null) { var p = this.canvas.getBoundingClientRect(); h[0] -= p.left, h[1] -= p.top } var c = h && LiteGraph.isInsideRectangle(h[0], h[1], t, e, n, i); l.fillStyle = u ? r : s, c && (l.fillStyle = "#AAA"), l.beginPath(), l.roundRect(t, e, n, i, [4]), l.fill(), null != o && o.constructor == String && (l.fillStyle = a, l.textAlign = "center", l.font = (.65 * i | 0) + "px Arial", l.fillText(o, t + .5 * n, e + .75 * i), l.textAlign = "left"); var d = c && !this.block_click; return c && this.blockClick(), d }, LGraphCanvas.prototype.isAreaClicked = function (t, e, n, i, o) { var s = this.mouse; LiteGraph.isInsideRectangle(s[0], s[1], t, e, n, i); var r = (s = this.last_click_position) && LiteGraph.isInsideRectangle(s[0], s[1], t, e, n, i), a = r && !this.block_click; return r && o && this.blockClick(), a }, LGraphCanvas.prototype.renderInfo = function (t, e, n) { e = e || 10, n = n || this.canvas.height - 80, t.save(), t.translate(e, n), t.font = "10px Arial", t.fillStyle = "#888", t.textAlign = "left", this.graph ? (t.fillText("T: " + this.graph.globaltime.toFixed(2) + "s", 5, 13), t.fillText("I: " + this.graph.iteration, 5, 26), t.fillText("N: " + this.graph._nodes.length + " [" + this.visible_nodes.length + "]", 5, 39), t.fillText("V: " + this.graph._version, 5, 52), t.fillText("FPS:" + this.fps.toFixed(2), 5, 65)) : t.fillText("No graph selected", 5, 13), t.restore() }, LGraphCanvas.prototype.drawBackCanvas = function () { var t = this.bgcanvas; (t.width != this.canvas.width || t.height != this.canvas.height) && (t.width = this.canvas.width, t.height = this.canvas.height), this.bgctx || (this.bgctx = this.bgcanvas.getContext("2d")); var e = this.bgctx; e.start && e.start(); var n = this.viewport || [0, 0, e.canvas.width, e.canvas.height]; if (this.clear_background && e.clearRect(n[0], n[1], n[2], n[3]), this._graph_stack && this._graph_stack.length) { e.save(), this._graph_stack[this._graph_stack.length - 1]; var i = this.graph._subgraph_node; e.strokeStyle = i.bgcolor, e.lineWidth = 10, e.strokeRect(1, 1, t.width - 2, t.height - 2), e.lineWidth = 1, e.font = "40px Arial", e.textAlign = "center", e.fillStyle = i.bgcolor || "#AAA"; for (var o = "", s = 1; s < this._graph_stack.length; ++s)o += this._graph_stack[s]._subgraph_node.getTitle() + " >> "; e.fillText(o + i.getTitle(), .5 * t.width, 40), e.restore() } var r = !1; if (this.onRenderBackground && (r = this.onRenderBackground(t, e)), this.viewport || (e.restore(), e.setTransform(1, 0, 0, 1, 0, 0)), this.visible_links.length = 0, this.graph) { if (e.save(), this.ds.toCanvasContext(e), this.ds.scale < 1.5 && !r && this.clear_background_color && (e.fillStyle = this.clear_background_color, e.fillRect(this.visible_area[0], this.visible_area[1], this.visible_area[2], this.visible_area[3])), this.background_image && this.ds.scale > .5 && !r) { if (this.zoom_modify_alpha ? e.globalAlpha = (1 - .5 / this.ds.scale) * this.editor_alpha : e.globalAlpha = this.editor_alpha, e.imageSmoothingEnabled = e.imageSmoothingEnabled = !1, !this._bg_img || this._bg_img.name != this.background_image) { this._bg_img = new Image, this._bg_img.name = this.background_image, this._bg_img.src = this.background_image; var a = this; this._bg_img.onload = function () { a.draw(!0, !0) } } var l = null; null == this._pattern && this._bg_img.width > 0 ? (l = e.createPattern(this._bg_img, "repeat"), this._pattern_img = this._bg_img, this._pattern = l) : l = this._pattern, l && (e.fillStyle = l, e.fillRect(this.visible_area[0], this.visible_area[1], this.visible_area[2], this.visible_area[3]), e.fillStyle = "transparent"), e.globalAlpha = 1, e.imageSmoothingEnabled = e.imageSmoothingEnabled = !0 } this.graph._groups.length && !this.live_mode && this.drawGroups(t, e), this.onDrawBackground && this.onDrawBackground(e, this.visible_area), this.onBackgroundRender && (console.error("WARNING! onBackgroundRender deprecated, now is named onDrawBackground "), this.onBackgroundRender = null), this.render_canvas_border && (e.strokeStyle = "#235", e.strokeRect(0, 0, t.width, t.height)), this.render_connections_shadows ? (e.shadowColor = "#000", e.shadowOffsetX = 0, e.shadowOffsetY = 0, e.shadowBlur = 6) : e.shadowColor = "rgba(0,0,0,0)", this.live_mode || this.drawConnections(e), e.shadowColor = "rgba(0,0,0,0)", e.restore() } e.finish && e.finish(), this.dirty_bgcanvas = !1, this.dirty_canvas = !0 }; var temp_vec2 = new Float32Array(2); LGraphCanvas.prototype.drawNode = function (t, e) { var n = !1; this.current_node = t; var i = t.color || t.constructor.color || LiteGraph.NODE_DEFAULT_COLOR, o = t.bgcolor || t.constructor.bgcolor || LiteGraph.NODE_DEFAULT_BGCOLOR; t.mouseOver && (n = !0); var s = this.ds.scale < .6; if (this.live_mode) { !t.flags.collapsed && (e.shadowColor = "transparent", t.onDrawForeground && t.onDrawForeground(e, this, this.canvas)); return } var r = this.editor_alpha; if (e.globalAlpha = r, this.render_shadows && !s ? (e.shadowColor = LiteGraph.DEFAULT_SHADOW_COLOR, e.shadowOffsetX = 2 * this.ds.scale, e.shadowOffsetY = 2 * this.ds.scale, e.shadowBlur = 3 * this.ds.scale) : e.shadowColor = "transparent", !t.flags.collapsed || !t.onDrawCollapsed || !0 != t.onDrawCollapsed(e, this)) { var a = t._shape || LiteGraph.BOX_SHAPE, l = temp_vec2; temp_vec2.set(t.size); var h = t.horizontal; if (t.flags.collapsed) { e.font = this.inner_text_font; var u = t.getTitle ? t.getTitle() : t.title; null != u && (t._collapsed_width = Math.min(t.size[0], e.measureText(u).width + 2 * LiteGraph.NODE_TITLE_HEIGHT), l[0] = t._collapsed_width, l[1] = 0) } t.clip_area && (e.save(), e.beginPath(), a == LiteGraph.BOX_SHAPE ? e.rect(0, 0, l[0], l[1]) : a == LiteGraph.ROUND_SHAPE ? e.roundRect(0, 0, l[0], l[1], [10]) : a == LiteGraph.CIRCLE_SHAPE && e.arc(.5 * l[0], .5 * l[1], .5 * l[0], 0, 2 * Math.PI), e.clip()), t.has_errors && (o = "red"), this.drawNodeShape(t, e, l, i, o, t.is_selected, t.mouseOver), e.shadowColor = "transparent", t.onDrawForeground && t.onDrawForeground(e, this, this.canvas), e.textAlign = h ? "center" : "left", e.font = this.inner_text_font; var p = !s, c = this.connecting_output, d = this.connecting_input; e.lineWidth = 1; var g = 0, f = new Float32Array(2); if (t.flags.collapsed) { if (this.render_collapsed_slots) { var v = null, $ = null; if (t.inputs) for (var y = 0; y < t.inputs.length; y++) { var _ = t.inputs[y]; if (null != _.link) { v = _; break } } if (t.outputs) for (var y = 0; y < t.outputs.length; y++) { var _ = t.outputs[y]; _.links && _.links.length && ($ = _) } if (v) { var m = 0, b = -.5 * LiteGraph.NODE_TITLE_HEIGHT; h && (m = .5 * t._collapsed_width, b = -LiteGraph.NODE_TITLE_HEIGHT), e.fillStyle = "#686", e.beginPath(), _.type === LiteGraph.EVENT || _.shape === LiteGraph.BOX_SHAPE ? e.rect(m - 7 + .5, b - 4, 14, 8) : _.shape === LiteGraph.ARROW_SHAPE ? (e.moveTo(m + 8, b), e.lineTo(m + -4, b - 4), e.lineTo(m + -4, b + 4), e.closePath()) : e.arc(m, b, 4, 0, 2 * Math.PI), e.fill() } if ($) { var m = t._collapsed_width, b = -.5 * LiteGraph.NODE_TITLE_HEIGHT; h && (m = .5 * t._collapsed_width, b = 0), e.fillStyle = "#686", e.strokeStyle = "black", e.beginPath(), _.type === LiteGraph.EVENT || _.shape === LiteGraph.BOX_SHAPE ? e.rect(m - 7 + .5, b - 4, 14, 8) : _.shape === LiteGraph.ARROW_SHAPE ? (e.moveTo(m + 6, b), e.lineTo(m - 6, b - 4), e.lineTo(m - 6, b + 4), e.closePath()) : e.arc(m, b, 4, 0, 2 * Math.PI), e.fill() } } } else { if (t.inputs) for (var y = 0; y < t.inputs.length; y++) { var _ = t.inputs[y], T = _.type, E = _.shape; e.globalAlpha = r, this.connecting_output && !LiteGraph.isValidConnection(_.type, c.type) && (e.globalAlpha = .4 * r), e.fillStyle = null != _.link ? _.color_on || this.default_connection_color_byType[T] || this.default_connection_color.input_on : _.color_off || this.default_connection_color_byTypeOff[T] || this.default_connection_color_byType[T] || this.default_connection_color.input_off; var k = t.getConnectionPos(!0, y, f); k[0] -= t.pos[0], k[1] -= t.pos[1], g < k[1] + .5 * LiteGraph.NODE_SLOT_HEIGHT && (g = k[1] + .5 * LiteGraph.NODE_SLOT_HEIGHT), e.beginPath(), "array" == T && (E = LiteGraph.GRID_SHAPE); var C = !0; if (_.type === LiteGraph.EVENT || _.shape === LiteGraph.BOX_SHAPE ? h ? e.rect(k[0] - 5 + .5, k[1] - 8 + .5, 10, 14) : e.rect(k[0] - 6 + .5, k[1] - 5 + .5, 14, 10) : E === LiteGraph.ARROW_SHAPE ? (e.moveTo(k[0] + 8, k[1] + .5), e.lineTo(k[0] - 4, k[1] + 6 + .5), e.lineTo(k[0] - 4, k[1] - 6 + .5), e.closePath()) : E === LiteGraph.GRID_SHAPE ? (e.rect(k[0] - 4, k[1] - 4, 2, 2), e.rect(k[0] - 1, k[1] - 4, 2, 2), e.rect(k[0] + 2, k[1] - 4, 2, 2), e.rect(k[0] - 4, k[1] - 1, 2, 2), e.rect(k[0] - 1, k[1] - 1, 2, 2), e.rect(k[0] + 2, k[1] - 1, 2, 2), e.rect(k[0] - 4, k[1] + 2, 2, 2), e.rect(k[0] - 1, k[1] + 2, 2, 2), e.rect(k[0] + 2, k[1] + 2, 2, 2), C = !1) : s ? e.rect(k[0] - 4, k[1] - 4, 8, 8) : e.arc(k[0], k[1], 4, 0, 2 * Math.PI), e.fill(), p) { var w = null != _.label ? _.label : _.name; w && (e.fillStyle = LiteGraph.NODE_TEXT_COLOR, h || _.dir == LiteGraph.UP ? e.fillText(w, k[0], k[1] - 10) : e.fillText(w, k[0] + 10, k[1] + 5)) } } if (e.textAlign = h ? "center" : "right", e.strokeStyle = "black", t.outputs) for (var y = 0; y < t.outputs.length; y++) { var _ = t.outputs[y], T = _.type, E = _.shape; this.connecting_input && !LiteGraph.isValidConnection(T, d.type) && (e.globalAlpha = .4 * r); var k = t.getConnectionPos(!1, y, f); k[0] -= t.pos[0], k[1] -= t.pos[1], g < k[1] + .5 * LiteGraph.NODE_SLOT_HEIGHT && (g = k[1] + .5 * LiteGraph.NODE_SLOT_HEIGHT), e.fillStyle = _.links && _.links.length ? _.color_on || this.default_connection_color_byType[T] || this.default_connection_color.output_on : _.color_off || this.default_connection_color_byTypeOff[T] || this.default_connection_color_byType[T] || this.default_connection_color.output_off, e.beginPath(), "array" == T && (E = LiteGraph.GRID_SHAPE); var C = !0; if (T === LiteGraph.EVENT || E === LiteGraph.BOX_SHAPE ? h ? e.rect(k[0] - 5 + .5, k[1] - 8 + .5, 10, 14) : e.rect(k[0] - 6 + .5, k[1] - 5 + .5, 14, 10) : E === LiteGraph.ARROW_SHAPE ? (e.moveTo(k[0] + 8, k[1] + .5), e.lineTo(k[0] - 4, k[1] + 6 + .5), e.lineTo(k[0] - 4, k[1] - 6 + .5), e.closePath()) : E === LiteGraph.GRID_SHAPE ? (e.rect(k[0] - 4, k[1] - 4, 2, 2), e.rect(k[0] - 1, k[1] - 4, 2, 2), e.rect(k[0] + 2, k[1] - 4, 2, 2), e.rect(k[0] - 4, k[1] - 1, 2, 2), e.rect(k[0] - 1, k[1] - 1, 2, 2), e.rect(k[0] + 2, k[1] - 1, 2, 2), e.rect(k[0] - 4, k[1] + 2, 2, 2), e.rect(k[0] - 1, k[1] + 2, 2, 2), e.rect(k[0] + 2, k[1] + 2, 2, 2), C = !1) : s ? e.rect(k[0] - 4, k[1] - 4, 8, 8) : e.arc(k[0], k[1], 4, 0, 2 * Math.PI), e.fill(), !s && C && e.stroke(), p) { var w = null != _.label ? _.label : _.name; w && (e.fillStyle = LiteGraph.NODE_TEXT_COLOR, h || _.dir == LiteGraph.DOWN ? e.fillText(w, k[0], k[1] - 8) : e.fillText(w, k[0] - 10, k[1] + 5)) } } if (e.textAlign = "left", e.globalAlpha = 1, t.widgets) { var N = g; (h || t.widgets_up) && (N = 2), null != t.widgets_start_y && (N = t.widgets_start_y), this.drawNodeWidgets(t, N, e, this.node_widget && this.node_widget[0] == t ? this.node_widget[1] : null) } } t.clip_area && e.restore(), e.globalAlpha = 1 } }, LGraphCanvas.prototype.drawLinkTooltip = function (t, e) { var n = e._pos; if (t.fillStyle = "black", t.beginPath(), t.arc(n[0], n[1], 3, 0, 2 * Math.PI), t.fill(), null != e.data && (!this.onDrawLinkTooltip || !0 != this.onDrawLinkTooltip(t, e, this))) { var i = e.data, o = null; if (null != (o = i.constructor === Number ? i.toFixed(2) : i.constructor === String ? '"' + i + '"' : i.constructor === Boolean ? String(i) : i.toToolTip ? i.toToolTip() : "[" + i.constructor.name + "]")) { o = o.substr(0, 30), t.font = "14px Courier New"; var s, r = t.measureText(o).width + 20, a = 24; t.shadowColor = "black", t.shadowOffsetX = 2, t.shadowOffsetY = 2, t.shadowBlur = 3, t.fillStyle = "#454", t.beginPath(), t.roundRect(n[0] - .5 * r, n[1] - 15 - a, r, a, [3]), t.moveTo(n[0] - 10, n[1] - 15), t.lineTo(n[0] + 10, n[1] - 15), t.lineTo(n[0], n[1] - 5), t.fill(), t.shadowColor = "transparent", t.textAlign = "center", t.fillStyle = "#CEC", t.fillText(o, n[0], n[1] - 15 - .3 * a) } } }; var tmp_area = new Float32Array(4); LGraphCanvas.prototype.drawNodeShape = function (t, e, n, i, o, s, r) { e.strokeStyle = i, e.fillStyle = o; var a = LiteGraph.NODE_TITLE_HEIGHT, l = this.ds.scale < .5, h = t._shape || t.constructor.shape || LiteGraph.ROUND_SHAPE, u = t.constructor.title_mode, p = !0; u == LiteGraph.TRANSPARENT_TITLE || u == LiteGraph.NO_TITLE ? p = !1 : u == LiteGraph.AUTOHIDE_TITLE && r && (p = !0); var c = tmp_area; c[0] = 0, c[1] = p ? -a : 0, c[2] = n[0] + 1, c[3] = p ? n[1] + a : n[1]; var d = e.globalAlpha; if (e.beginPath(), h == LiteGraph.BOX_SHAPE || l ? e.fillRect(c[0], c[1], c[2], c[3]) : h == LiteGraph.ROUND_SHAPE || h == LiteGraph.CARD_SHAPE ? e.roundRect(c[0], c[1], c[2], c[3], h == LiteGraph.CARD_SHAPE ? [this.round_radius, this.round_radius, 0, 0] : [this.round_radius]) : h == LiteGraph.CIRCLE_SHAPE && e.arc(.5 * n[0], .5 * n[1], .5 * n[0], 0, 2 * Math.PI), e.fill(), !t.flags.collapsed && p && (e.shadowColor = "transparent", e.fillStyle = "rgba(0,0,0,0.2)", e.fillRect(0, -1, c[2], 2)), e.shadowColor = "transparent", t.onDrawBackground && t.onDrawBackground(e, this, this.canvas, this.graph_mouse), p || u == LiteGraph.TRANSPARENT_TITLE) { if (t.onDrawTitleBar) t.onDrawTitleBar(e, a, n, this.ds.scale, i); else if (u != LiteGraph.TRANSPARENT_TITLE && (t.constructor.title_color || this.render_title_colored)) { var g = t.constructor.title_color || i; if (t.flags.collapsed && (e.shadowColor = LiteGraph.DEFAULT_SHADOW_COLOR), this.use_gradients) { var f = LGraphCanvas.gradients[g]; f || ((f = LGraphCanvas.gradients[g] = e.createLinearGradient(0, 0, 400, 0)).addColorStop(0, g), f.addColorStop(1, "#000")), e.fillStyle = f } else e.fillStyle = g; e.beginPath(), h == LiteGraph.BOX_SHAPE || l ? e.rect(0, -a, n[0] + 1, a) : (h == LiteGraph.ROUND_SHAPE || h == LiteGraph.CARD_SHAPE) && e.roundRect(0, -a, n[0] + 1, a, t.flags.collapsed ? [this.round_radius] : [this.round_radius, this.round_radius, 0, 0]), e.fill(), e.shadowColor = "transparent" } var v = !1; LiteGraph.node_box_coloured_by_mode && LiteGraph.NODE_MODES_COLORS[t.mode] && (v = LiteGraph.NODE_MODES_COLORS[t.mode]), LiteGraph.node_box_coloured_when_on && (v = t.action_triggered ? "#FFF" : t.execute_triggered ? "#AAA" : v); var $ = 10; if (t.onDrawTitleBox ? t.onDrawTitleBox(e, a, n, this.ds.scale) : h == LiteGraph.ROUND_SHAPE || h == LiteGraph.CIRCLE_SHAPE || h == LiteGraph.CARD_SHAPE ? (l && (e.fillStyle = "black", e.beginPath(), e.arc(.5 * a, -.5 * a, .5 * $ + 1, 0, 2 * Math.PI), e.fill()), e.fillStyle = t.boxcolor || v || LiteGraph.NODE_DEFAULT_BOXCOLOR, l ? e.fillRect(.5 * a - .5 * $, -.5 * a - .5 * $, $, $) : (e.beginPath(), e.arc(.5 * a, -.5 * a, .5 * $, 0, 2 * Math.PI), e.fill())) : (l && (e.fillStyle = "black", e.fillRect((a - $) * .5 - 1, -((a + $) * .5) - 1, $ + 2, $ + 2)), e.fillStyle = t.boxcolor || v || LiteGraph.NODE_DEFAULT_BOXCOLOR, e.fillRect((a - $) * .5, -((a + $) * .5), $, $)), e.globalAlpha = d, t.onDrawTitleText && t.onDrawTitleText(e, a, n, this.ds.scale, this.title_text_font, s), !l) { e.font = this.title_text_font; var y = String(t.getTitle()); y && (s ? e.fillStyle = LiteGraph.NODE_SELECTED_TITLE_COLOR : e.fillStyle = t.constructor.title_text_color || this.node_title_color, t.flags.collapsed ? (e.textAlign = "left", e.measureText(y), e.fillText(y.substr(0, 20), a, LiteGraph.NODE_TITLE_TEXT_Y - a), e.textAlign = "left") : (e.textAlign = "left", e.fillText(y, a, LiteGraph.NODE_TITLE_TEXT_Y - a))) } if (!t.flags.collapsed && t.subgraph && !t.skip_subgraph_button) { var _ = LiteGraph.NODE_TITLE_HEIGHT, m = t.size[0] - _, b = LiteGraph.isInsideRectangle(this.graph_mouse[0] - t.pos[0], this.graph_mouse[1] - t.pos[1], m + 2, -_ + 2, _ - 4, _ - 4); e.fillStyle = b ? "#888" : "#555", h == LiteGraph.BOX_SHAPE || l ? e.fillRect(m + 2, -_ + 2, _ - 4, _ - 4) : (e.beginPath(), e.roundRect(m + 2, -_ + 2, _ - 4, _ - 4, [4]), e.fill()), e.fillStyle = "#333", e.beginPath(), e.moveTo(m + .2 * _, -(.6 * _)), e.lineTo(m + .8 * _, -(.6 * _)), e.lineTo(m + .5 * _, -(.3 * _)), e.fill() } t.onDrawTitle && t.onDrawTitle(e) } s && (t.onBounding && t.onBounding(c), u == LiteGraph.TRANSPARENT_TITLE && (c[1] -= a, c[3] += a), e.lineWidth = 1, e.globalAlpha = .8, e.beginPath(), h == LiteGraph.BOX_SHAPE ? e.rect(-6 + c[0], -6 + c[1], 12 + c[2], 12 + c[3]) : h == LiteGraph.ROUND_SHAPE || h == LiteGraph.CARD_SHAPE && t.flags.collapsed ? e.roundRect(-6 + c[0], -6 + c[1], 12 + c[2], 12 + c[3], [2 * this.round_radius]) : h == LiteGraph.CARD_SHAPE ? e.roundRect(-6 + c[0], -6 + c[1], 12 + c[2], 12 + c[3], [2 * this.round_radius, 2, 2 * this.round_radius, 2]) : h == LiteGraph.CIRCLE_SHAPE && e.arc(.5 * n[0], .5 * n[1], .5 * n[0] + 6, 0, 2 * Math.PI), e.strokeStyle = LiteGraph.NODE_BOX_OUTLINE_COLOR, e.stroke(), e.strokeStyle = i, e.globalAlpha = 1), t.execute_triggered > 0 && t.execute_triggered--, t.action_triggered > 0 && t.action_triggered-- }; var margin_area = new Float32Array(4), link_bounding = new Float32Array(4), tempA = new Float32Array(2), tempB = new Float32Array(2); function compareObjects(t, e) { for (var n in t) if (t[n] != e[n]) return !1; return !0 } function distance(t, e) { return Math.sqrt((e[0] - t[0]) * (e[0] - t[0]) + (e[1] - t[1]) * (e[1] - t[1])) } function colorToString(t) { return "rgba(" + Math.round(255 * t[0]).toFixed() + "," + Math.round(255 * t[1]).toFixed() + "," + Math.round(255 * t[2]).toFixed() + "," + (4 == t.length ? t[3].toFixed(2) : "1.0") + ")" } function isInsideRectangle(t, e, n, i, o, s) { return !!(n < t) && !!(n + o > t) && !!(i < e) && !!(i + s > e) } function growBounding(t, e, n) { e < t[0] ? t[0] = e : e > t[2] && (t[2] = e), n < t[1] ? t[1] = n : n > t[3] && (t[3] = n) } function isInsideBounding(t, e) { return !(t[0] < e[0][0]) && !(t[1] < e[0][1]) && !(t[0] > e[1][0]) && !(t[1] > e[1][1]) } function overlapBounding(t, e) { var n = t[0] + t[2], i = t[1] + t[3], o = e[0] + e[2], s = e[1] + e[3]; return !(t[0] > o) && !(t[1] > s) && !(n < e[0]) && !(i < e[1]) } function hex2num(t) { "#" == t.charAt(0) && (t = t.slice(1)), t = t.toUpperCase(); for (var e, n, i = "0123456789ABCDEF", o = [, , ,], s = 0, r = 0; r < 6; r += 2)e = i.indexOf(t.charAt(r)), n = i.indexOf(t.charAt(r + 1)), o[s] = 16 * e + n, s++; return o } function num2hex(t) { for (var e, n, i = "0123456789ABCDEF", o = "#", s = 0; s < 3; s++)e = t[s] / 16, n = t[s] % 16, o += i.charAt(e) + i.charAt(n); return o } function ContextMenu(t, e) { e = e || {}, this.options = e; var n = this; e.parentMenu && (e.parentMenu.constructor !== this.constructor ? (console.error("parentMenu must be of class ContextMenu, ignoring it"), e.parentMenu = null) : (this.parentMenu = e.parentMenu, this.parentMenu.lock = !0, this.parentMenu.current_submenu = this)); var i = null; e.event && (i = e.event.constructor.name), "MouseEvent" !== i && "CustomEvent" !== i && "PointerEvent" !== i && (console.error("Event passed to ContextMenu is not of type MouseEvent or CustomEvent. Ignoring it. (" + i + ")"), e.event = null); var o = document.createElement("div"); function s(t) { var n = parseInt(o.style.top); return o.style.top = (n + t.deltaY * e.scroll_speed).toFixed() + "px", t.preventDefault(), !0 } if (o.className = "litegraph litecontextmenu litemenubar-panel", e.className && (o.className += " " + e.className), o.style.minWidth = 100, o.style.minHeight = 100, o.style.pointerEvents = "none", setTimeout(function () { o.style.pointerEvents = "auto" }, 100), LiteGraph.pointerListenerAdd(o, "up", function (t) { return t.preventDefault(), !0 }, !0), o.addEventListener("contextmenu", function (t) { return 2 == t.button && (t.preventDefault(), !1) }, !0), LiteGraph.pointerListenerAdd(o, "down", function (t) { if (2 == t.button) return n.close(), t.preventDefault(), !0 }, !0), e.scroll_speed || (e.scroll_speed = .1), o.addEventListener("wheel", s, !0), o.addEventListener("mousewheel", s, !0), this.root = o, e.title) { var r = document.createElement("div"); r.className = "litemenu-title", r.innerHTML = e.title, o.appendChild(r) } for (var a = 0, l = 0; l < t.length; l++) { var h = t.constructor == Array ? t[l] : l; null != h && h.constructor !== String && (h = void 0 === h.content ? String(h) : h.content); var u = t[l]; this.addItem(h, u, e), a++ } LiteGraph.pointerListenerAdd(o, "enter", function (t) { o.closing_timer && clearTimeout(o.closing_timer) }); var p = document; e.event && (p = e.event.target.ownerDocument), p || (p = document), p.fullscreenElement ? p.fullscreenElement.appendChild(o) : p.body.appendChild(o); var c = e.left || 0, d = e.top || 0; if (e.event) { if (c = e.event.clientX - 10, d = e.event.clientY - 10, e.title && (d -= 20), e.parentMenu) { var g = e.parentMenu.root.getBoundingClientRect(); c = g.left + g.width } var f = document.body.getBoundingClientRect(), v = o.getBoundingClientRect(); 0 == f.height && console.error("document.body height is 0. That is dangerous, set html,body { height: 100%; }"), f.width && c > f.width - v.width - 10 && (c = f.width - v.width - 10), f.height && d > f.height - v.height - 10 && (d = f.height - v.height - 10) } o.style.left = c + "px", o.style.top = d + "px", e.scale && (o.style.transform = "scale(" + e.scale + ")") } function CurveEditor(t) { this.points = t, this.selected = -1, this.nearest = -1, this.size = null, this.must_update = !0, this.margin = 5 } function clamp(t, e, n) { return e > t ? e : n < t ? n : t } LGraphCanvas.prototype.drawConnections = function (t) { var e = LiteGraph.getTime(), n = this.visible_area; margin_area[0] = n[0] - 20, margin_area[1] = n[1] - 20, margin_area[2] = n[2] + 40, margin_area[3] = n[3] + 40, t.lineWidth = this.connections_width, t.fillStyle = "#AAA", t.strokeStyle = "#AAA", t.globalAlpha = this.editor_alpha; for (var i = this.graph._nodes, o = 0, s = i.length; o < s; ++o) { var r = i[o]; if (r.inputs && r.inputs.length) for (var a = 0; a < r.inputs.length; ++a) { var l = r.inputs[a]; if (l && null != l.link) { var h = l.link, u = this.graph.links[h]; if (u) { var p = this.graph.getNodeById(u.origin_id); if (null != p) { var c = u.origin_slot, d = null; d = -1 == c ? [p.pos[0] + 10, p.pos[1] + 10] : p.getConnectionPos(!1, c, tempA); var g = r.getConnectionPos(!0, a, tempB); if (link_bounding[0] = d[0], link_bounding[1] = d[1], link_bounding[2] = g[0] - d[0], link_bounding[3] = g[1] - d[1], link_bounding[2] < 0 && (link_bounding[0] += link_bounding[2], link_bounding[2] = Math.abs(link_bounding[2])), link_bounding[3] < 0 && (link_bounding[1] += link_bounding[3], link_bounding[3] = Math.abs(link_bounding[3])), overlapBounding(link_bounding, margin_area)) { var f = p.outputs[c], v = r.inputs[a]; if (f && v) { var $ = f.dir || (p.horizontal ? LiteGraph.DOWN : LiteGraph.RIGHT), y = v.dir || (r.horizontal ? LiteGraph.UP : LiteGraph.LEFT); if (this.renderLink(t, d, g, u, !1, 0, null, $, y), u && u._last_time && e - u._last_time < 1e3) { var _ = 2 - (e - u._last_time) * .002, m = t.globalAlpha; t.globalAlpha = m * _, this.renderLink(t, d, g, u, !0, _, "white", $, y), t.globalAlpha = m } } } } } } } } t.globalAlpha = 1 }, LGraphCanvas.prototype.renderLink = function (t, e, n, i, o, s, r, a, l, h) { i && this.visible_links.push(i), !r && i && (r = i.color || LGraphCanvas.link_type_colors[i.type]), r || (r = this.default_link_color), null != i && this.highlighted_links[i.id] && (r = "#FFF"), a = a || LiteGraph.RIGHT, l = l || LiteGraph.LEFT; var u = distance(e, n); this.render_connections_border && this.ds.scale > .6 && (t.lineWidth = this.connections_width + 4), t.lineJoin = "round", (h = h || 1) > 1 && (t.lineWidth = .5), t.beginPath(); for (var p = 0; p < h; p += 1) { var c = (p - (h - 1) * .5) * 5; if (this.links_render_mode == LiteGraph.SPLINE_LINK) { t.moveTo(e[0], e[1] + c); var d = 0, g = 0, f = 0, v = 0; switch (a) { case LiteGraph.LEFT: d = -.25 * u; break; case LiteGraph.RIGHT: d = .25 * u; break; case LiteGraph.UP: g = -.25 * u; break; case LiteGraph.DOWN: g = .25 * u }switch (l) { case LiteGraph.LEFT: f = -.25 * u; break; case LiteGraph.RIGHT: f = .25 * u; break; case LiteGraph.UP: v = -.25 * u; break; case LiteGraph.DOWN: v = .25 * u }t.bezierCurveTo(e[0] + d, e[1] + g + c, n[0] + f, n[1] + v + c, n[0], n[1] + c) } else if (this.links_render_mode == LiteGraph.LINEAR_LINK) { t.moveTo(e[0], e[1] + c); var d = 0, g = 0, f = 0, v = 0; switch (a) { case LiteGraph.LEFT: d = -1; break; case LiteGraph.RIGHT: d = 1; break; case LiteGraph.UP: g = -1; break; case LiteGraph.DOWN: g = 1 }switch (l) { case LiteGraph.LEFT: f = -1; break; case LiteGraph.RIGHT: f = 1; break; case LiteGraph.UP: v = -1; break; case LiteGraph.DOWN: v = 1 }var $ = 15; t.lineTo(e[0] + d * $, e[1] + g * $ + c), t.lineTo(n[0] + f * $, n[1] + v * $ + c), t.lineTo(n[0], n[1] + c) } else { if (this.links_render_mode != LiteGraph.STRAIGHT_LINK) return; t.moveTo(e[0], e[1]); var y = e[0], _ = e[1], m = n[0], b = n[1]; a == LiteGraph.RIGHT ? y += 10 : _ += 10, l == LiteGraph.LEFT ? m -= 10 : b -= 10, t.lineTo(y, _), t.lineTo((y + m) * .5, _), t.lineTo((y + m) * .5, b), t.lineTo(m, b), t.lineTo(n[0], n[1]) } } this.render_connections_border && this.ds.scale > .6 && !o && (t.strokeStyle = "rgba(0,0,0,0.5)", t.stroke()), t.lineWidth = this.connections_width, t.fillStyle = t.strokeStyle = r, t.stroke(); var T = this.computeConnectionPoint(e, n, .5, a, l); if (i && i._pos && (i._pos[0] = T[0], i._pos[1] = T[1]), this.ds.scale >= .6 && this.highquality_render && l != LiteGraph.CENTER) { if (this.render_connection_arrows) { var E = this.computeConnectionPoint(e, n, .25, a, l), k = this.computeConnectionPoint(e, n, .26, a, l), C = this.computeConnectionPoint(e, n, .75, a, l), w = this.computeConnectionPoint(e, n, .76, a, l), N = 0, O = 0; this.render_curved_connections ? (N = -Math.atan2(k[0] - E[0], k[1] - E[1]), O = -Math.atan2(w[0] - C[0], w[1] - C[1])) : O = N = n[1] > e[1] ? 0 : Math.PI, t.save(), t.translate(E[0], E[1]), t.rotate(N), t.beginPath(), t.moveTo(-5, -3), t.lineTo(0, 7), t.lineTo(5, -3), t.fill(), t.restore(), t.save(), t.translate(C[0], C[1]), t.rotate(O), t.beginPath(), t.moveTo(-5, -3), t.lineTo(0, 7), t.lineTo(5, -3), t.fill(), t.restore() } t.beginPath(), t.arc(T[0], T[1], 5, 0, 2 * Math.PI), t.fill() } if (s) { t.fillStyle = r; for (var p = 0; p < 5; ++p) { var S = (.001 * LiteGraph.getTime() + .2 * p) % 1, T = this.computeConnectionPoint(e, n, S, a, l); t.beginPath(), t.arc(T[0], T[1], 5, 0, 2 * Math.PI), t.fill() } } }, LGraphCanvas.prototype.computeConnectionPoint = function (t, e, n, i, o) { i = i || LiteGraph.RIGHT, o = o || LiteGraph.LEFT; var s = distance(t, e), r = t, a = [t[0], t[1]], l = [e[0], e[1]], h = e; switch (i) { case LiteGraph.LEFT: a[0] += -.25 * s; break; case LiteGraph.RIGHT: a[0] += .25 * s; break; case LiteGraph.UP: a[1] += -.25 * s; break; case LiteGraph.DOWN: a[1] += .25 * s }switch (o) { case LiteGraph.LEFT: l[0] += -.25 * s; break; case LiteGraph.RIGHT: l[0] += .25 * s; break; case LiteGraph.UP: l[1] += -.25 * s; break; case LiteGraph.DOWN: l[1] += .25 * s }var u, p = (1 - n) * (1 - n) * (1 - n), c = 3 * ((1 - n) * (1 - n)) * n, d = 3 * (1 - n) * (n * n), g = n * n * n; return [p * r[0] + c * a[0] + d * l[0] + g * h[0], p * r[1] + c * a[1] + d * l[1] + g * h[1]] }, LGraphCanvas.prototype.drawExecutionOrder = function (t) { t.shadowColor = "transparent", t.globalAlpha = .25, t.textAlign = "center", t.strokeStyle = "white", t.globalAlpha = .75; for (var e = this.visible_nodes, n = 0; n < e.length; ++n) { var i = e[n]; t.fillStyle = "black", t.fillRect(i.pos[0] - LiteGraph.NODE_TITLE_HEIGHT, i.pos[1] - LiteGraph.NODE_TITLE_HEIGHT, LiteGraph.NODE_TITLE_HEIGHT, LiteGraph.NODE_TITLE_HEIGHT), 0 == i.order && t.strokeRect(i.pos[0] - LiteGraph.NODE_TITLE_HEIGHT + .5, i.pos[1] - LiteGraph.NODE_TITLE_HEIGHT + .5, LiteGraph.NODE_TITLE_HEIGHT, LiteGraph.NODE_TITLE_HEIGHT), t.fillStyle = "#FFF", t.fillText(i.order, i.pos[0] + -.5 * LiteGraph.NODE_TITLE_HEIGHT, i.pos[1] - 6) } t.globalAlpha = 1 }, LGraphCanvas.prototype.drawNodeWidgets = function (t, e, n, i) { if (!t.widgets || !t.widgets.length) return 0; var o = t.size[0], s = t.widgets; e += 2; var r = LiteGraph.NODE_WIDGET_HEIGHT, a = this.ds.scale > .5; n.save(), n.globalAlpha = this.editor_alpha; for (var l = LiteGraph.WIDGET_OUTLINE_COLOR, h = LiteGraph.WIDGET_BGCOLOR, u = LiteGraph.WIDGET_TEXT_COLOR, p = LiteGraph.WIDGET_SECONDARY_TEXT_COLOR, c = 15, d = 0; d < s.length; ++d) { var g = s[d], f = e; g.y && (f = g.y), g.last_y = f, n.strokeStyle = l, n.fillStyle = "#222", n.textAlign = "left", g.disabled && (n.globalAlpha *= .5); var v = g.width || o; switch (g.type) { case "button": g.clicked && (n.fillStyle = "#AAA", g.clicked = !1, this.dirty_canvas = !0), n.fillRect(c, f, v - 2 * c, r), a && !g.disabled && n.strokeRect(c, f, v - 2 * c, r), a && (n.textAlign = "center", n.fillStyle = u, n.fillText(g.label || g.name, .5 * v, f + .7 * r)); break; case "toggle": if (n.textAlign = "left", n.strokeStyle = l, n.fillStyle = h, n.beginPath(), a ? n.roundRect(c, f, v - 2 * c, r, [.5 * r]) : n.rect(c, f, v - 2 * c, r), n.fill(), a && !g.disabled && n.stroke(), n.fillStyle = g.value ? "#89A" : "#333", n.beginPath(), n.arc(v - 2 * c, f + .5 * r, .36 * r, 0, 2 * Math.PI), n.fill(), a) { n.fillStyle = p; let $ = g.label || g.name; null != $ && n.fillText($, 2 * c, f + .7 * r), n.fillStyle = g.value ? u : p, n.textAlign = "right", n.fillText(g.value ? g.options.on || "true" : g.options.off || "false", v - 40, f + .7 * r) } break; case "slider": n.fillStyle = h, n.fillRect(c, f, v - 2 * c, r); var y = g.options.max - g.options.min, _ = (g.value - g.options.min) / y; if (_ < 0 && (_ = 0), _ > 1 && (_ = 1), n.fillStyle = g.options.hasOwnProperty("slider_color") ? g.options.slider_color : i == g ? "#89A" : "#678", n.fillRect(c, f, _ * (v - 2 * c), r), a && !g.disabled && n.strokeRect(c, f, v - 2 * c, r), g.marker) { var m = (g.marker - g.options.min) / y; m < 0 && (m = 0), m > 1 && (m = 1), n.fillStyle = g.options.hasOwnProperty("marker_color") ? g.options.marker_color : "#AA9", n.fillRect(c + m * (v - 2 * c), f, 2, r) } a && (n.textAlign = "center", n.fillStyle = u, n.fillText(g.label || g.name + "  " + Number(g.value).toFixed(null != g.options.precision ? g.options.precision : 3), .5 * v, f + .7 * r)); break; case "number": case "combo": if (n.textAlign = "left", n.strokeStyle = l, n.fillStyle = h, n.beginPath(), a ? n.roundRect(c, f, v - 2 * c, r, [.5 * r]) : n.rect(c, f, v - 2 * c, r), n.fill(), a) { if (g.disabled || n.stroke(), n.fillStyle = u, g.disabled || (n.beginPath(), n.moveTo(c + 16, f + 5), n.lineTo(c + 6, f + .5 * r), n.lineTo(c + 16, f + r - 5), n.fill(), n.beginPath(), n.moveTo(v - c - 16, f + 5), n.lineTo(v - c - 6, f + .5 * r), n.lineTo(v - c - 16, f + r - 5), n.fill()), n.fillStyle = p, n.fillText(g.label || g.name, 2 * c + 5, f + .7 * r), n.fillStyle = u, n.textAlign = "right", "number" == g.type) n.fillText(Number(g.value).toFixed(void 0 !== g.options.precision ? g.options.precision : 3), v - 2 * c - 20, f + .7 * r); else { var b = g.value; if (g.options.values) { var T = g.options.values; T.constructor === Function && (T = T()), T && T.constructor !== Array && (b = T[g.value]) } n.fillText(b, v - 2 * c - 20, f + .7 * r) } } break; case "string": case "text": if (n.textAlign = "left", n.strokeStyle = l, n.fillStyle = h, n.beginPath(), a ? n.roundRect(c, f, v - 2 * c, r, [.5 * r]) : n.rect(c, f, v - 2 * c, r), n.fill(), a) { g.disabled || n.stroke(), n.save(), n.beginPath(), n.rect(c, f, v - 2 * c, r), n.clip(), n.fillStyle = p; let E = g.label || g.name; null != E && n.fillText(E, 2 * c, f + .7 * r), n.fillStyle = u, n.textAlign = "right", n.fillText(String(g.value).substr(0, 30), v - 2 * c, f + .7 * r), n.restore() } break; default: g.draw && g.draw(n, t, v, f, r) }e += (g.computeSize ? g.computeSize(v)[1] : r) + 4, n.globalAlpha = this.editor_alpha } n.restore(), n.textAlign = "left" }, LGraphCanvas.prototype.processNodeWidgets = function (node, pos, event, active_widget) { if (!node.widgets || !node.widgets.length || !this.allow_interaction && !node.flags.allow_interaction) return null; for (var x = pos[0] - node.pos[0], y = pos[1] - node.pos[1], width = node.size[0], deltaX = event.deltaX || event.deltax || 0, that = this, ref_window = this.getCanvasWindow(), i = 0; i < node.widgets.length; ++i) { var w = node.widgets[i]; if (w && !w.disabled) { var widget_height = w.computeSize ? w.computeSize(width)[1] : LiteGraph.NODE_WIDGET_HEIGHT, widget_width = w.width || width; if (w == active_widget || !(x < 6) && !(x > widget_width - 12) && !(y < w.last_y) && !(y > w.last_y + widget_height) && void 0 !== w.last_y) { var old_value = w.value; switch (w.type) { case "button": event.type === LiteGraph.pointerevents_method + "down" && (w.callback && setTimeout(function () { w.callback(w, that, node, pos, event) }, 20), w.clicked = !0, this.dirty_canvas = !0); break; case "slider": var old_value = w.value, nvalue = clamp((x - 15) / (widget_width - 30), 0, 1); if (w.options.read_only) break; w.value = w.options.min + (w.options.max - w.options.min) * nvalue, old_value != w.value && setTimeout(function () { inner_value_change(w, w.value) }, 20), this.dirty_canvas = !0; break; case "number": case "combo": var old_value = w.value; if (event.type == LiteGraph.pointerevents_method + "move" && "number" == w.type) deltaX && (w.value += .1 * deltaX * (w.options.step || 1)), null != w.options.min && w.value < w.options.min && (w.value = w.options.min), null != w.options.max && w.value > w.options.max && (w.value = w.options.max); else if (event.type == LiteGraph.pointerevents_method + "down") { var values = w.options.values; values && values.constructor === Function && (values = w.options.values(w, node)); var values_list = null; "number" != w.type && (values_list = values.constructor === Array ? values : Object.keys(values)); var delta = x < 40 ? -1 : x > widget_width - 40 ? 1 : 0; if ("number" == w.type) w.value += .1 * delta * (w.options.step || 1), null != w.options.min && w.value < w.options.min && (w.value = w.options.min), null != w.options.max && w.value > w.options.max && (w.value = w.options.max); else if (delta) { var index = -1; this.last_mouseclick = 0, (index = values.constructor === Object ? values_list.indexOf(String(w.value)) + delta : values_list.indexOf(w.value) + delta) >= values_list.length && (index = values_list.length - 1), index < 0 && (index = 0), values.constructor === Array ? w.value = values[index] : w.value = index } else { var text_values = values != values_list ? Object.values(values) : values; function inner_clicked(t, e, n) { return values != values_list && (t = text_values.indexOf(t)), this.value = t, inner_value_change(this, t), that.dirty_canvas = !0, !1 } new LiteGraph.ContextMenu(text_values, { scale: Math.max(1, this.ds.scale), event: event, className: "dark", callback: inner_clicked.bind(w) }, ref_window) } } else if (event.type == LiteGraph.pointerevents_method + "up" && "number" == w.type) { var delta = x < 40 ? -1 : x > widget_width - 40 ? 1 : 0; event.click_time < 200 && 0 == delta && this.prompt("Value", w.value, (function (v) { if (/^[0-9+\-*/()\s]+|\d+\.\d+$/.test(v)) try { v = eval(v) } catch (e) { } this.value = Number(v), inner_value_change(this, this.value) }).bind(w), event) } old_value != w.value && setTimeout((function () { inner_value_change(this, this.value) }).bind(w), 20), this.dirty_canvas = !0; break; case "toggle": event.type == LiteGraph.pointerevents_method + "down" && (w.value = !w.value, setTimeout(function () { inner_value_change(w, w.value) }, 20)); break; case "string": case "text": event.type == LiteGraph.pointerevents_method + "down" && this.prompt("Value", w.value, (function (t) { inner_value_change(this, t) }).bind(w), event, !!w.options && w.options.multiline); break; default: w.mouse && (this.dirty_canvas = w.mouse(event, [x, y], node)) }return old_value != w.value && (node.onWidgetChanged && node.onWidgetChanged(w.name, w.value, old_value, w), node.graph._version++), w } } } function inner_value_change(t, e) { "number" == t.type && (e = Number(e)), t.value = e, t.options && t.options.property && void 0 !== node.properties[t.options.property] && node.setProperty(t.options.property, e), t.callback && t.callback(t.value, that, node, pos, event) } return null }, LGraphCanvas.prototype.drawGroups = function (t, e) { if (this.graph) { var n = this.graph._groups; e.save(), e.globalAlpha = .5 * this.editor_alpha; for (var i = 0; i < n.length; ++i) { var o = n[i]; if (overlapBounding(this.visible_area, o._bounding)) { e.fillStyle = o.color || "#335", e.strokeStyle = o.color || "#335"; var s = o._pos, r = o._size; e.globalAlpha = .25 * this.editor_alpha, e.beginPath(), e.rect(s[0] + .5, s[1] + .5, r[0], r[1]), e.fill(), e.globalAlpha = this.editor_alpha, e.stroke(), e.beginPath(), e.moveTo(s[0] + r[0], s[1] + r[1]), e.lineTo(s[0] + r[0] - 10, s[1] + r[1]), e.lineTo(s[0] + r[0], s[1] + r[1] - 10), e.fill(); var a = o.font_size || LiteGraph.DEFAULT_GROUP_FONT_SIZE; e.font = a + "px Arial", e.textAlign = "left", e.fillText(o.title, s[0] + 4, s[1] + a) } } e.restore() } }, LGraphCanvas.prototype.adjustNodesSize = function () { for (var t = this.graph._nodes, e = 0; e < t.length; ++e)t[e].size = t[e].computeSize(); this.setDirty(!0, !0) }, LGraphCanvas.prototype.resize = function (t, e) { if (!t && !e) { var n = this.canvas.parentNode; t = n.offsetWidth, e = n.offsetHeight } (this.canvas.width != t || this.canvas.height != e) && (this.canvas.width = t, this.canvas.height = e, this.bgcanvas.width = this.canvas.width, this.bgcanvas.height = this.canvas.height, this.setDirty(!0, !0)) }, LGraphCanvas.prototype.switchLiveMode = function (t) { if (!t) { this.live_mode = !this.live_mode, this.dirty_canvas = !0, this.dirty_bgcanvas = !0; return } var e = this, n = this.live_mode ? 1.1 : .9; this.live_mode && (this.live_mode = !1, this.editor_alpha = .1); var i = setInterval(function () { e.editor_alpha *= n, e.dirty_canvas = !0, e.dirty_bgcanvas = !0, n < 1 && e.editor_alpha < .01 && (clearInterval(i), n < 1 && (e.live_mode = !0)), n > 1 && e.editor_alpha > .99 && (clearInterval(i), e.editor_alpha = 1) }, 1) }, LGraphCanvas.prototype.onNodeSelectionChange = function (t) { }, LGraphCanvas.onGroupAdd = function (t, e, n) { var i = LGraphCanvas.active_canvas; i.getCanvasWindow(); var o = new LiteGraph.LGraphGroup; o.pos = i.convertEventToCanvasOffset(n), i.graph.add(o) }, LGraphCanvas.getBoundaryNodes = function (t) { let e = null, n = null, i = null, o = null; for (let s in t) { let r = t[s], [a, l] = r.pos, [h, u] = r.size; (null === e || l < e.pos[1]) && (e = r), (null === n || a + h > n.pos[0] + n.size[0]) && (n = r), (null === i || l + u > i.pos[1] + i.size[1]) && (i = r), (null === o || a < o.pos[0]) && (o = r) } return { top: e, right: n, bottom: i, left: o } }, LGraphCanvas.prototype.boundaryNodesForSelection = function () { return LGraphCanvas.getBoundaryNodes(Object.values(this.selected_nodes)) }, LGraphCanvas.alignNodes = function (t, e, n) { if (!t) return; let i = LGraphCanvas.active_canvas, o = []; for (let [s, r] of (o = void 0 === n ? LGraphCanvas.getBoundaryNodes(t) : { top: n, right: n, bottom: n, left: n }, Object.entries(i.selected_nodes))) switch (e) { case "right": r.pos[0] = o.right.pos[0] + o.right.size[0] - r.size[0]; break; case "left": r.pos[0] = o.left.pos[0]; break; case "top": r.pos[1] = o.top.pos[1]; break; case "bottom": r.pos[1] = o.bottom.pos[1] + o.bottom.size[1] - r.size[1] }i.dirty_canvas = !0, i.dirty_bgcanvas = !0 }, LGraphCanvas.onNodeAlign = function (t, e, n, i, o) { new LiteGraph.ContextMenu(["Top", "Bottom", "Left", "Right"], { event: n, callback: s, parentMenu: i }); function s(t) { LGraphCanvas.alignNodes(LGraphCanvas.active_canvas.selected_nodes, t.toLowerCase(), o) } }, LGraphCanvas.onGroupAlign = function (t, e, n, i) { new LiteGraph.ContextMenu(["Top", "Bottom", "Left", "Right"], { event: n, callback: o, parentMenu: i }); function o(t) { LGraphCanvas.alignNodes(LGraphCanvas.active_canvas.selected_nodes, t.toLowerCase()) } }, LGraphCanvas.onMenuAdd = function (t, e, n, i, o) { var s = LGraphCanvas.active_canvas, r = s.getCanvasWindow(), a = s.graph; if (a) return l("", i), !1; function l(t, e) { var i = LiteGraph.getNodeTypesCategories(s.filter || a.filter).filter(function (e) { return e.startsWith(t) }), h = []; i.map(function (e) { if (e) { var n, i = RegExp("^(" + t + ")"), o = e.replace(i, "").split("/")[0], s = "" === t ? o + "/" : t + o + "/", r = o; -1 != r.indexOf("::") && (r = r.split("::")[1]), -1 === h.findIndex(function (t) { return t.value === s }) && h.push({ value: s, content: r, has_submenu: !0, callback: function (t, e, n, i) { l(t.value, i) } }) } }), LiteGraph.getNodeTypesInCategory(t.slice(0, -1), s.filter || a.filter).map(function (t) { if (!t.skip_list) { var e = { value: t.type, content: t.title, has_submenu: !1, callback: function (t, e, n, i) { var r = i.getFirstEvent(); s.graph.beforeChange(); var a = LiteGraph.createNode(t.value); a && (a.pos = s.convertEventToCanvasOffset(r), s.graph.add(a)), o && o(a), s.graph.afterChange() } }; h.push(e) } }), new LiteGraph.ContextMenu(h, { event: n, parentMenu: e }, r) } }, LGraphCanvas.onMenuCollapseAll = function () { }, LGraphCanvas.onMenuNodeEdit = function () { }, LGraphCanvas.showMenuNodeOptionalInputs = function (t, e, n, i, o) { if (o) { var s, r = this, a = LGraphCanvas.active_canvas.getCanvasWindow(), e = o.optional_inputs; o.onGetInputs && (e = o.onGetInputs()); var l = []; if (e) for (var h = 0; h < e.length; h++) { var u = e[h]; if (!u) { l.push(null); continue } var p = u[0]; u[2] || (u[2] = {}), u[2].label && (p = u[2].label), u[2].removable = !0; var c = { content: p, value: u }; u[1] == LiteGraph.ACTION && (c.className = "event"), l.push(c) } if (o.onMenuNodeInputs) { var d = o.onMenuNodeInputs(l); d && (l = d) } if (!l.length) { console.log("no input entries"); return } return new LiteGraph.ContextMenu(l, { event: n, callback: g, parentMenu: i, node: o }, a), !1 } function g(t, e, n) { o && (t.callback && t.callback.call(r, o, t, e, n), t.value && (o.graph.beforeChange(), o.addInput(t.value[0], t.value[1], t.value[2]), o.onNodeInputAdd && o.onNodeInputAdd(t.value), o.setDirtyCanvas(!0, !0), o.graph.afterChange())) } }, LGraphCanvas.showMenuNodeOptionalOutputs = function (t, e, n, i, o) { if (o) { var s = this, r = LGraphCanvas.active_canvas.getCanvasWindow(), e = o.optional_outputs; o.onGetOutputs && (e = o.onGetOutputs()); var a = []; if (e) for (var l = 0; l < e.length; l++) { var h = e[l]; if (!h) { a.push(null); continue } if (!o.flags || !o.flags.skip_repeated_outputs || -1 == o.findOutputSlot(h[0])) { var u = h[0]; h[2] || (h[2] = {}), h[2].label && (u = h[2].label), h[2].removable = !0; var p = { content: u, value: h }; h[1] == LiteGraph.EVENT && (p.className = "event"), a.push(p) } } if (this.onMenuNodeOutputs && (a = this.onMenuNodeOutputs(a)), LiteGraph.do_add_triggers_slots && -1 == o.findOutputSlot("onExecuted") && a.push({ content: "On Executed", value: ["onExecuted", LiteGraph.EVENT, { nameLocked: !0 }], className: "event" }), o.onMenuNodeOutputs) { var c = o.onMenuNodeOutputs(a); c && (a = c) } if (a.length) return new LiteGraph.ContextMenu(a, { event: n, callback: d, parentMenu: i, node: o }, r), !1 } function d(t, e, n) { if (o) { if (t.callback && t.callback.call(s, o, t, e, n), t.value) { var r = t.value[1]; if (r && (r.constructor === Object || r.constructor === Array)) { var a = []; for (var l in r) a.push({ content: l, value: r[l] }); return new LiteGraph.ContextMenu(a, { event: e, callback: d, parentMenu: i, node: o }), !1 } o.graph.beforeChange(), o.addOutput(t.value[0], t.value[1], t.value[2]), o.onNodeOutputAdd && o.onNodeOutputAdd(t.value), o.setDirtyCanvas(!0, !0), o.graph.afterChange() } } } }, LGraphCanvas.onShowMenuNodeProperties = function (t, e, n, i, o) { if (o && o.properties) { var s = LGraphCanvas.active_canvas, r = s.getCanvasWindow(), a = []; for (var l in o.properties) { var t = void 0 !== o.properties[l] ? o.properties[l] : " "; "object" == typeof t && (t = JSON.stringify(t)); var h = o.getPropertyInfo(l); ("enum" == h.type || "combo" == h.type) && (t = LGraphCanvas.getPropertyPrintableValue(t, h.values)), t = LGraphCanvas.decodeHTML(t), a.push({ content: "<span class='property_name'>" + (h.label ? h.label : l) + "</span><span class='property_value'>" + t + "</span>", value: l }) } if (a.length) return new LiteGraph.ContextMenu(a, { event: n, callback: u, parentMenu: i, allow_html: !0, node: o }, r), !1 } function u(t, e, n, i) { if (o) { var r = this.getBoundingClientRect(); s.showEditPropertyValue(o, t.value, { position: [r.left, r.top] }) } } }, LGraphCanvas.decodeHTML = function (t) { var e = document.createElement("div"); return e.innerText = t, e.innerHTML }, LGraphCanvas.onMenuResizeNode = function (t, e, n, i, o) { if (o) { var s = function (t) { t.size = t.computeSize(), t.onResize && t.onResize(t.size) }, r = LGraphCanvas.active_canvas; if (!r.selected_nodes || Object.keys(r.selected_nodes).length <= 1) s(o); else for (var a in r.selected_nodes) s(r.selected_nodes[a]); o.setDirtyCanvas(!0, !0) } }, LGraphCanvas.prototype.showLinkMenu = function (t, e) { var n = this, i = n.graph.getNodeById(t.origin_id), o = n.graph.getNodeById(t.target_id), s = !1; i && i.outputs && i.outputs[t.origin_slot] && (s = i.outputs[t.origin_slot].type); var r = !1; o && o.outputs && o.outputs[t.target_slot] && (r = o.inputs[t.target_slot].type); var a = ["Add Node", null, "Delete", null], l = new LiteGraph.ContextMenu(a, { event: e, title: null != t.data ? t.data.constructor.name : null, callback: h }); function h(e, a, h) { switch (e) { case "Add Node": LGraphCanvas.onMenuAdd(null, null, h, l, function (e) { e.inputs && e.inputs.length && e.outputs && e.outputs.length && i.connectByType(t.origin_slot, e, s) && (e.connectByType(t.target_slot, o, r), e.pos[0] -= .5 * e.size[0]) }); break; case "Delete": n.graph.removeLink(t.id) } } return !1 }, LGraphCanvas.prototype.createDefaultNodeForSlot = function (t) { var t = t || {}, e = Object.assign({ nodeFrom: null, slotFrom: null, nodeTo: null, slotTo: null, position: [], nodeType: null, posAdd: [0, 0], posSizeFix: [0, 0] }, t), n = this, i = e.nodeFrom && null !== e.slotFrom, o = !i && e.nodeTo && null !== e.slotTo; if (!i && !o) return console.warn("No data passed to createDefaultNodeForSlot " + e.nodeFrom + " " + e.slotFrom + " " + e.nodeTo + " " + e.slotTo), !1; if (!e.nodeType) return console.warn("No type to createDefaultNodeForSlot"), !1; var s = i ? e.nodeFrom : e.nodeTo, r = i ? e.slotFrom : e.slotTo, a = !1; switch (typeof r) { case "string": a = i ? s.findOutputSlot(r, !1) : s.findInputSlot(r, !1), r = i ? s.outputs[r] : s.inputs[r]; break; case "object": a = i ? s.findOutputSlot(r.name) : s.findInputSlot(r.name); break; case "number": a = r, r = i ? s.outputs[r] : s.inputs[r]; break; default: return console.warn("Cant get slot information " + r), !1 }(!1 === r || !1 === a) && console.warn("createDefaultNodeForSlot bad slotX " + r + " " + a); var l = r.type == LiteGraph.EVENT ? "_event_" : r.type, h = i ? LiteGraph.slot_types_default_out : LiteGraph.slot_types_default_in; if (h && h[l]) { if (r.link, nodeNewType = !1, "object" == typeof h[l] || "array" == typeof h[l]) { for (var u in h[l]) if (e.nodeType == h[l][u] || "AUTO" == e.nodeType) { nodeNewType = h[l][u]; break } } else (e.nodeType == h[l] || "AUTO" == e.nodeType) && (nodeNewType = h[l]); if (nodeNewType) { var p = !1; "object" == typeof nodeNewType && nodeNewType.node && (p = nodeNewType, nodeNewType = nodeNewType.node); var c = LiteGraph.createNode(nodeNewType); if (c) { if (p) { if (p.properties) for (var d in p.properties) c.addProperty(d, p.properties[d]); if (p.inputs) for (var d in c.inputs = [], p.inputs) c.addOutput(p.inputs[d][0], p.inputs[d][1]); if (p.outputs) for (var d in c.outputs = [], p.outputs) c.addOutput(p.outputs[d][0], p.outputs[d][1]); p.title && (c.title = p.title), p.json && c.configure(p.json) } return n.graph.add(c), c.pos = [e.position[0] + e.posAdd[0] + (e.posSizeFix[0] ? e.posSizeFix[0] * c.size[0] : 0), e.position[1] + e.posAdd[1] + (e.posSizeFix[1] ? e.posSizeFix[1] * c.size[1] : 0)], i ? e.nodeFrom.connectByType(a, c, l) : e.nodeTo.connectByTypeOutput(a, c, l), !0 } console.log("failed creating " + nodeNewType) } } return !1 }, LGraphCanvas.prototype.showConnectionMenu = function (t) { var t = t || {}, e = Object.assign({ nodeFrom: null, slotFrom: null, nodeTo: null, slotTo: null, e: null }, t), n = this, i = e.nodeFrom && e.slotFrom, o = !i && e.nodeTo && e.slotTo; if (!i && !o) return console.warn("No data passed to showConnectionMenu"), !1; var s = i ? e.nodeFrom : e.nodeTo, r = i ? e.slotFrom : e.slotTo, a = !1; switch (typeof r) { case "string": a = i ? s.findOutputSlot(r, !1) : s.findInputSlot(r, !1), r = i ? s.outputs[r] : s.inputs[r]; break; case "object": a = i ? s.findOutputSlot(r.name) : s.findInputSlot(r.name); break; case "number": a = r, r = i ? s.outputs[r] : s.inputs[r]; break; default: return console.warn("Cant get slot information " + r), !1 }var l = ["Add Node", null]; n.allow_searchbox && (l.push("Search"), l.push(null)); var h = r.type == LiteGraph.EVENT ? "_event_" : r.type, u = i ? LiteGraph.slot_types_default_out : LiteGraph.slot_types_default_in; if (u && u[h]) { if ("object" == typeof u[h] || "array" == typeof u[h]) for (var p in u[h]) l.push(u[h][p]); else l.push(u[h]) } var c = new LiteGraph.ContextMenu(l, { event: e.e, title: (r && "" != r.name ? r.name + (h ? " | " : "") : "") + (r && h ? h : ""), callback: d }); function d(t, o, s) { switch (t) { case "Add Node": LGraphCanvas.onMenuAdd(null, null, s, c, function (t) { i ? e.nodeFrom.connectByType(a, t, h) : e.nodeTo.connectByTypeOutput(a, t, h) }); break; case "Search": i ? n.showSearchBox(s, { node_from: e.nodeFrom, slot_from: r, type_filter_in: h }) : n.showSearchBox(s, { node_to: e.nodeTo, slot_from: r, type_filter_out: h }); break; default: n.createDefaultNodeForSlot(Object.assign(e, { position: [e.e.canvasX, e.e.canvasY], nodeType: t })) } } return !1 }, LGraphCanvas.onShowPropertyEditor = function (t, e, n, i, o) { var s = t.property || "title", r = o[s], a = document.createElement("div"); a.is_modified = !1, a.className = "graphdialog", a.innerHTML = "<span class='name'></span><input autofocus type='text' class='value'/><button>OK</button>", a.close = function () { a.parentNode && a.parentNode.removeChild(a) }, a.querySelector(".name").innerText = s; var l = a.querySelector(".value"); l && (l.value = r, l.addEventListener("blur", function (t) { this.focus() }), l.addEventListener("keydown", function (t) { if (a.is_modified = !0, 27 == t.keyCode) a.close(); else if (13 == t.keyCode) g(); else if (13 != t.keyCode && "textarea" != t.target.localName) return; t.preventDefault(), t.stopPropagation() })); var h = LGraphCanvas.active_canvas.canvas, u = h.getBoundingClientRect(), p = -20, c = -20; u && (p -= u.left, c -= u.top), event ? (a.style.left = event.clientX + p + "px", a.style.top = event.clientY + c + "px") : (a.style.left = .5 * h.width + p + "px", a.style.top = .5 * h.height + c + "px"), a.querySelector("button").addEventListener("click", g), h.parentNode.appendChild(a), l && l.focus(); var d = null; function g() { l && f(l.value) } function f(e) { "Number" == t.type ? e = Number(e) : "Boolean" == t.type && (e = Boolean(e)), o[s] = e, a.parentNode && a.parentNode.removeChild(a), o.setDirtyCanvas(!0, !0) } a.addEventListener("mouseleave", function (t) { LiteGraph.dialog_close_on_mouse_leave && !a.is_modified && LiteGraph.dialog_close_on_mouse_leave && (d = setTimeout(a.close, LiteGraph.dialog_close_on_mouse_leave_delay)) }), a.addEventListener("mouseenter", function (t) { LiteGraph.dialog_close_on_mouse_leave && d && clearTimeout(d) }) }, LGraphCanvas.prototype.prompt = function (t, e, n, i, o) { var s = this; t = t || ""; var r = document.createElement("div"); r.is_modified = !1, r.className = "graphdialog rounded", o ? r.innerHTML = "<span class='name'></span> <textarea autofocus class='value'></textarea><button class='rounded'>OK</button>" : r.innerHTML = "<span class='name'></span> <input autofocus type='text' class='value'/><button class='rounded'>OK</button>", r.close = function () { s.prompt_box = null, r.parentNode && r.parentNode.removeChild(r) }; var a = LGraphCanvas.active_canvas.canvas; a.parentNode.appendChild(r), this.ds.scale > 1 && (r.style.transform = "scale(" + this.ds.scale + ")"); var l = null, h = !1; LiteGraph.pointerListenerAdd(r, "leave", function (t) { !h && LiteGraph.dialog_close_on_mouse_leave && !r.is_modified && LiteGraph.dialog_close_on_mouse_leave && (l = setTimeout(r.close, LiteGraph.dialog_close_on_mouse_leave_delay)) }), LiteGraph.pointerListenerAdd(r, "enter", function (t) { LiteGraph.dialog_close_on_mouse_leave && l && clearTimeout(l) }); var u = r.querySelectorAll("select"); u && u.forEach(function (t) { t.addEventListener("click", function (t) { h++ }), t.addEventListener("blur", function (t) { h = 0 }), t.addEventListener("change", function (t) { h = -1 }) }), s.prompt_box && s.prompt_box.close(), s.prompt_box = r, r.querySelector(".name").innerText = t; var p = r.querySelector(".value"); p.value = e; var c = p; c.addEventListener("keydown", function (t) { if (r.is_modified = !0, 27 == t.keyCode) r.close(); else { if (13 != t.keyCode || "textarea" == t.target.localName) return; n && n(this.value), r.close() } t.preventDefault(), t.stopPropagation() }), r.querySelector("button").addEventListener("click", function (t) { n && n(c.value), s.setDirty(!0), r.close() }); var d = a.getBoundingClientRect(), g = -20, f = -20; return d && (g -= d.left, f -= d.top), i ? (r.style.left = i.clientX + g + "px", r.style.top = i.clientY + f + "px") : (r.style.left = .5 * a.width + g + "px", r.style.top = .5 * a.height + f + "px"), setTimeout(function () { c.focus() }, 10), r }, LGraphCanvas.search_limit = -1, LGraphCanvas.prototype.showSearchBox = function (t, e) { e = Object.assign({ slot_from: null, node_from: null, node_to: null, do_type_filter: LiteGraph.search_filter_enabled, type_filter_in: !1, type_filter_out: !1, show_general_if_none_on_typefilter: !0, show_general_after_typefiltered: !0, hide_on_mouse_leave: LiteGraph.search_hide_on_mouse_leave, show_all_if_empty: !0, show_all_on_open: LiteGraph.search_show_all_on_open }, e || {}); var n = this, i = LGraphCanvas.active_canvas, o = i.canvas, s = o.ownerDocument || document, r = document.createElement("div"); if (r.className = "litegraph litesearchbox graphdialog rounded", r.innerHTML = "<span class='name'>Search</span> <input autofocus type='text' class='value rounded'/>", e.do_type_filter && (r.innerHTML += "<select class='slot_in_type_filter'><option value=''></option></select>", r.innerHTML += "<select class='slot_out_type_filter'><option value=''></option></select>"), r.innerHTML += "<div class='helper'></div>", s.fullscreenElement ? s.fullscreenElement.appendChild(r) : (s.body.appendChild(r), s.body.style.overflow = "hidden"), e.do_type_filter) var a = r.querySelector(".slot_in_type_filter"), l = r.querySelector(".slot_out_type_filter"); if (r.close = function () { n.search_box = null, this.blur(), o.focus(), s.body.style.overflow = "", setTimeout(function () { n.canvas.focus() }, 20), r.parentNode && r.parentNode.removeChild(r) }, this.ds.scale > 1 && (r.style.transform = "scale(" + this.ds.scale + ")"), e.hide_on_mouse_leave) { var h = !1, u = null; LiteGraph.pointerListenerAdd(r, "enter", function (t) { u && (clearTimeout(u), u = null) }), LiteGraph.pointerListenerAdd(r, "leave", function (t) { !h && (u = setTimeout(function () { r.close() }, 500)) }), e.do_type_filter && (a.addEventListener("click", function (t) { h++ }), a.addEventListener("blur", function (t) { h = 0 }), a.addEventListener("change", function (t) { h = -1 }), l.addEventListener("click", function (t) { h++ }), l.addEventListener("blur", function (t) { h = 0 }), l.addEventListener("change", function (t) { h = -1 })) } n.search_box && n.search_box.close(), n.search_box = r; var p = r.querySelector(".helper"), c = null, d = null, g = null, f = r.querySelector("input"); if (f && (f.addEventListener("blur", function (t) { n.search_box && this.focus() }), f.addEventListener("keydown", function (t) { if (38 == t.keyCode) k(!1); else if (40 == t.keyCode) k(!0); else if (27 == t.keyCode) r.close(); else if (13 == t.keyCode) C(), g ? E(g.innerHTML) : c ? E(c) : r.close(); else { d && clearInterval(d), d = setTimeout(C, 250); return } return t.preventDefault(), t.stopPropagation(), t.stopImmediatePropagation(), !0 })), e.do_type_filter) { if (a) { var v = LiteGraph.slot_types_in, $ = v.length; (e.type_filter_in == LiteGraph.EVENT || e.type_filter_in == LiteGraph.ACTION) && (e.type_filter_in = "_event_"); for (var y = 0; y < $; y++) { var _ = document.createElement("option"); _.value = v[y], _.innerHTML = v[y], a.appendChild(_), !1 !== e.type_filter_in && (e.type_filter_in + "").toLowerCase() == (v[y] + "").toLowerCase() && (_.selected = !0) } a.addEventListener("change", function () { C() }) } if (l) { var v = LiteGraph.slot_types_out, $ = v.length; (e.type_filter_out == LiteGraph.EVENT || e.type_filter_out == LiteGraph.ACTION) && (e.type_filter_out = "_event_"); for (var y = 0; y < $; y++) { var _ = document.createElement("option"); _.value = v[y], _.innerHTML = v[y], l.appendChild(_), !1 !== e.type_filter_out && (e.type_filter_out + "").toLowerCase() == (v[y] + "").toLowerCase() && (_.selected = !0) } l.addEventListener("change", function () { C() }) } } var m = o.getBoundingClientRect(), b = (t ? t.clientX : m.left + .5 * m.width) - 80, T = (t ? t.clientY : m.top + .5 * m.height) - 20; function E(o) { if (o) { if (n.onSearchBoxSelection) n.onSearchBoxSelection(o, t, i); else { var s = LiteGraph.searchbox_extras[o.toLowerCase()]; s && (o = s.type), i.graph.beforeChange(); var a = LiteGraph.createNode(o); if (a && (a.pos = i.convertEventToCanvasOffset(t), i.graph.add(a, !1)), s && s.data) { if (s.data.properties) for (var l in s.data.properties) a.addProperty(l, s.data.properties[l]); if (s.data.inputs) for (var l in a.inputs = [], s.data.inputs) a.addOutput(s.data.inputs[l][0], s.data.inputs[l][1]); if (s.data.outputs) for (var l in a.outputs = [], s.data.outputs) a.addOutput(s.data.outputs[l][0], s.data.outputs[l][1]); s.data.title && (a.title = s.data.title), s.data.json && a.configure(s.data.json) } if (e.node_from) { var h = !1; switch (typeof e.slot_from) { case "string": h = e.node_from.findOutputSlot(e.slot_from); break; case "object": -1 == (h = e.slot_from.name ? e.node_from.findOutputSlot(e.slot_from.name) : -1) && void 0 !== e.slot_from.slot_index && (h = e.slot_from.slot_index); break; case "number": h = e.slot_from; break; default: h = 0 }void 0 !== e.node_from.outputs[h] && !1 !== h && h > -1 && e.node_from.connectByType(h, a, e.node_from.outputs[h].type) } if (e.node_to) { var h = !1; switch (typeof e.slot_from) { case "string": h = e.node_to.findInputSlot(e.slot_from); break; case "object": -1 == (h = e.slot_from.name ? e.node_to.findInputSlot(e.slot_from.name) : -1) && void 0 !== e.slot_from.slot_index && (h = e.slot_from.slot_index); break; case "number": h = e.slot_from; break; default: h = 0 }void 0 !== e.node_to.inputs[h] && !1 !== h && h > -1 && e.node_to.connectByTypeOutput(h, a, e.node_to.inputs[h].type) } i.graph.afterChange() } } r.close() } function k(t) { var e = g; g && g.classList.remove("selected"), g ? (g = t ? g.nextSibling : g.previousSibling) || (g = e) : g = t ? p.childNodes[0] : p.childNodes[p.childNodes.length], g && (g.classList.add("selected"), g.scrollIntoView({ block: "end", behavior: "smooth" })) } function C() { d = null; var t = f.value; if (c = null, p.innerHTML = "", t || e.show_all_if_empty) { if (n.onSearchBox) { var o = n.onSearchBox(p, t, i); if (o) for (var s = 0; s < o.length; ++s)y(o[s]) } else { var r = 0; t = t.toLowerCase(); var a = i.filter || i.graph.filter; if (e.do_type_filter && n.search_box) var l = n.search_box.querySelector(".slot_in_type_filter"), h = n.search_box.querySelector(".slot_out_type_filter"); else var l = !1, h = !1; for (var s in LiteGraph.searchbox_extras) { var u = LiteGraph.searchbox_extras[s]; if (e.show_all_if_empty && !t || -1 !== u.desc.toLowerCase().indexOf(t)) { var g = LiteGraph.registered_node_types[u.type]; if ((!g || g.filter == a) && $(u.type) && (y(u.desc, "searchbox_extra"), -1 !== LGraphCanvas.search_limit && r++ > LGraphCanvas.search_limit)) break } } var v = null; if (Array.prototype.filter) var v = Object.keys(LiteGraph.registered_node_types).filter($); else for (var s in v = [], LiteGraph.registered_node_types) $(s) && v.push(s); for (var s = 0; s < v.length && (y(v[s]), !(-1 !== LGraphCanvas.search_limit && r++ > LGraphCanvas.search_limit)); s++); if (e.show_general_after_typefiltered && (l.value || h.value)) { for (var s in filtered_extra = [], LiteGraph.registered_node_types) $(s, { inTypeOverride: !!l && !!l.value && "*", outTypeOverride: !!h && !!h.value && "*" }) && filtered_extra.push(s); for (var s = 0; s < filtered_extra.length && (y(filtered_extra[s], "generic_type"), !(-1 !== LGraphCanvas.search_limit && r++ > LGraphCanvas.search_limit)); s++); } if ((l.value || h.value) && 0 == p.childNodes.length && e.show_general_if_none_on_typefilter) { for (var s in filtered_extra = [], LiteGraph.registered_node_types) $(s, { skipFilter: !0 }) && filtered_extra.push(s); for (var s = 0; s < filtered_extra.length && (y(filtered_extra[s], "not_in_filter"), !(-1 !== LGraphCanvas.search_limit && r++ > LGraphCanvas.search_limit)); s++); } function $(n, i) { var i = i || {}, o = Object.assign({ skipFilter: !1, inTypeOverride: !1, outTypeOverride: !1 }, i), s = LiteGraph.registered_node_types[n]; if (a && s.filter != a || (!e.show_all_if_empty || t) && -1 === n.toLowerCase().indexOf(t)) return !1; if (e.do_type_filter && !o.skipFilter) { var r = n, u = l.value; if (!1 !== o.inTypeOverride && (u = o.inTypeOverride), l && u && LiteGraph.registered_slot_in_types[u] && LiteGraph.registered_slot_in_types[u].nodes) { var p = LiteGraph.registered_slot_in_types[u].nodes.includes(r); if (!1 === p) return !1 } var u = h.value; if (!1 !== o.outTypeOverride && (u = o.outTypeOverride), h && u && LiteGraph.registered_slot_out_types[u] && LiteGraph.registered_slot_out_types[u].nodes) { var p = LiteGraph.registered_slot_out_types[u].nodes.includes(r); if (!1 === p) return !1 } } return !0 } } } function y(t, e) { var n = document.createElement("div"); c || (c = t), n.innerText = t, n.dataset.type = escape(t), n.className = "litegraph lite-search-item", e && (n.className += " " + e), n.addEventListener("click", function (t) { E(unescape(this.dataset.type)) }), p.appendChild(n) } } return r.style.left = b + "px", r.style.top = T + "px", t.layerY > m.height - 200 && (p.style.maxHeight = m.height - t.layerY - 20 + "px"), f.focus(), e.show_all_on_open && C(), r }, LGraphCanvas.prototype.showEditPropertyValue = function (t, e, n) { if (t && void 0 !== t.properties[e]) { n = n || {}; var i, o = t.getPropertyInfo(e), s = o.type, r = ""; if ("string" == s || "number" == s || "array" == s || "object" == s) r = "<input autofocus type='text' class='value'/>"; else if (("enum" == s || "combo" == s) && o.values) { for (var a in r = "<select autofocus type='text' class='value'>", o.values) { var l = a; o.values.constructor === Array && (l = o.values[a]), r += "<option value='" + l + "' " + (l == t.properties[e] ? "selected" : "") + ">" + o.values[a] + "</option>" } r += "</select>" } else if ("boolean" == s || "toggle" == s) r = "<input autofocus type='checkbox' class='value' " + (t.properties[e] ? "checked" : "") + "/>"; else { console.warn("unknown type: " + s); return } var h = this.createDialog("<span class='name'>" + (o.label ? o.label : e) + "</span>" + r + "<button>OK</button>", n), u = !1; if (("enum" == s || "combo" == s) && o.values) (u = h.querySelector("select")).addEventListener("change", function (t) { h.modified(), c(t.target.value) }); else if ("boolean" == s || "toggle" == s) (u = h.querySelector("input")) && u.addEventListener("click", function (t) { h.modified(), c(!!u.checked) }); else if (u = h.querySelector("input")) { u.addEventListener("blur", function (t) { this.focus() }); var l = void 0 !== t.properties[e] ? t.properties[e] : ""; "string" !== s && (l = JSON.stringify(l)), u.value = l, u.addEventListener("keydown", function (t) { if (27 == t.keyCode) h.close(); else if (13 == t.keyCode) p(); else if (13 != t.keyCode) { h.modified(); return } t.preventDefault(), t.stopPropagation() }) } return u && u.focus(), h.querySelector("button").addEventListener("click", p), h } function p() { c(u.value) } function c(i) { o && o.values && o.values.constructor === Object && void 0 != o.values[i] && (i = o.values[i]), "number" == typeof t.properties[e] && (i = Number(i)), ("array" == s || "object" == s) && (i = JSON.parse(i)), t.properties[e] = i, t.graph && t.graph._version++, t.onPropertyChanged && t.onPropertyChanged(e, i), n.onclose && n.onclose(), h.close(), t.setDirtyCanvas(!0, !0) } }, LGraphCanvas.prototype.createDialog = function (t, e) { e = Object.assign({ checkForInput: !1, closeOnLeave: !0, closeOnLeave_checkModified: !0 }, e || {}); var n = document.createElement("div"); n.className = "graphdialog", n.innerHTML = t, n.is_modified = !1; var i = this.canvas.getBoundingClientRect(), o = -20, s = -20; if (i && (o -= i.left, s -= i.top), e.position ? (o += e.position[0], s += e.position[1]) : e.event ? (o += e.event.clientX, s += e.event.clientY) : (o += .5 * this.canvas.width, s += .5 * this.canvas.height), n.style.left = o + "px", n.style.top = s + "px", this.canvas.parentNode.appendChild(n), e.checkForInput) { var r = [], a = !1; (r = n.querySelectorAll("input")) && r.forEach(function (t) { t.addEventListener("keydown", function (t) { if (n.modified(), 27 == t.keyCode) n.close(); else if (13 != t.keyCode) return; t.preventDefault(), t.stopPropagation() }), a || t.focus() }) } n.modified = function () { n.is_modified = !0 }, n.close = function () { n.parentNode && n.parentNode.removeChild(n) }; var l = null, h = !1; n.addEventListener("mouseleave", function (t) { !h && (e.closeOnLeave || LiteGraph.dialog_close_on_mouse_leave) && !n.is_modified && LiteGraph.dialog_close_on_mouse_leave && (l = setTimeout(n.close, LiteGraph.dialog_close_on_mouse_leave_delay)) }), n.addEventListener("mouseenter", function (t) { (e.closeOnLeave || LiteGraph.dialog_close_on_mouse_leave) && l && clearTimeout(l) }); var u = n.querySelectorAll("select"); return u && u.forEach(function (t) { t.addEventListener("click", function (t) { h++ }), t.addEventListener("blur", function (t) { h = 0 }), t.addEventListener("change", function (t) { h = -1 }) }), n }, LGraphCanvas.prototype.createPanel = function (t, e) { var n = (e = e || {}).window || window, i = document.createElement("div"); if (i.className = "litegraph dialog", i.innerHTML = "<div class='dialog-header'><span class='dialog-title'></span></div><div class='dialog-content'></div><div style='display:none;' class='dialog-alt-content'></div><div class='dialog-footer'></div>", i.header = i.querySelector(".dialog-header"), e.width && (i.style.width = e.width + (e.width.constructor === Number ? "px" : "")), e.height && (i.style.height = e.height + (e.height.constructor === Number ? "px" : "")), e.closable) { var o = document.createElement("span"); o.innerHTML = "&#10005;", o.classList.add("close"), o.addEventListener("click", function () { i.close() }), i.header.appendChild(o) } return i.title_element = i.querySelector(".dialog-title"), i.title_element.innerText = t, i.content = i.querySelector(".dialog-content"), i.alt_content = i.querySelector(".dialog-alt-content"), i.footer = i.querySelector(".dialog-footer"), i.close = function () { i.onClose && "function" == typeof i.onClose && i.onClose(), i.parentNode && i.parentNode.removeChild(i), this.parentNode && this.parentNode.removeChild(this) }, i.toggleAltContent = function (t) { if (void 0 !== t) var e = t ? "block" : "none", n = t ? "none" : "block"; else var e = "block" != i.alt_content.style.display ? "block" : "none", n = "block" != i.alt_content.style.display ? "none" : "block"; i.alt_content.style.display = e, i.content.style.display = n }, i.toggleFooterVisibility = function (t) { if (void 0 !== t) var e = t ? "block" : "none"; else var e = "block" != i.footer.style.display ? "block" : "none"; i.footer.style.display = e }, i.clear = function () { this.content.innerHTML = "" }, i.addHTML = function (t, e, n) { var o = document.createElement("div"); return e && (o.className = e), o.innerHTML = t, n ? i.footer.appendChild(o) : i.content.appendChild(o), o }, i.addButton = function (t, e, n) { var o = document.createElement("button"); return o.innerText = t, o.options = n, o.classList.add("btn"), o.addEventListener("click", e), i.footer.appendChild(o), o }, i.addSeparator = function () { var t = document.createElement("div"); t.className = "separator", i.content.appendChild(t) }, i.addWidget = function (t, e, o, s, r) { s = s || {}; var a = String(o); "number" == (t = t.toLowerCase()) && (a = o.toFixed(3)); var l = document.createElement("div"); l.className = "property", l.innerHTML = "<span class='property_name'></span><span class='property_value'></span>", l.querySelector(".property_name").innerText = s.label || e; var h = l.querySelector(".property_value"); if (h.innerText = a, l.dataset.property = e, l.dataset.type = s.type || t, l.options = s, l.value = o, "code" == t) l.addEventListener("click", function (t) { i.inner_showCodePad(this.dataset.property) }); else if ("boolean" == t) l.classList.add("boolean"), o && l.classList.add("bool-on"), l.addEventListener("click", function () { var t = this.dataset.property; this.value = !this.value, this.classList.toggle("bool-on"), this.querySelector(".property_value").innerText = this.value ? "true" : "false", u(t, this.value) }); else if ("string" == t || "number" == t) h.setAttribute("contenteditable", !0), h.addEventListener("keydown", function (e) { "Enter" != e.code || "string" == t && e.shiftKey || (e.preventDefault(), this.blur()) }), h.addEventListener("blur", function () { var t = this.innerText, e = this.parentNode.dataset.property; "number" == this.parentNode.dataset.type && (t = Number(t)), u(e, t) }); else if ("enum" == t || "combo" == t) { var a = LGraphCanvas.getPropertyPrintableValue(o, s.values); h.innerText = a, h.addEventListener("click", function (t) { var e = s.values || [], i = this.parentNode.dataset.property, o = this; function r(t, e, n) { return o.innerText = t, u(i, t), !1 } new LiteGraph.ContextMenu(e, { event: t, className: "dark", callback: r }, n) }) } function u(t, e) { s.callback && s.callback(t, e, s), r && r(t, e, s) } return i.content.appendChild(l), l }, i.onOpen && "function" == typeof i.onOpen && i.onOpen(), i }, LGraphCanvas.getPropertyPrintableValue = function (t, e) { if (!e || e.constructor === Array) return String(t); if (e.constructor === Object) { var n = ""; for (var i in e) if (e[i] == t) { n = i; break } return String(t) + " (" + n + ")" } }, LGraphCanvas.prototype.closePanels = function () { var t = document.querySelector("#node-panel"); t && t.close(); var t = document.querySelector("#option-panel"); t && t.close() }, LGraphCanvas.prototype.showShowGraphOptionsPanel = function (t, e, n, i) { if (this.constructor && "HTMLDivElement" == this.constructor.name) { if (!e || !e.event || !e.event.target || !e.event.target.lgraphcanvas) { console.warn("Canvas not found"); return } var o = e.event.target.lgraphcanvas } else var o = this; o.closePanels(); var s = o.getCanvasWindow(); function r() { panel.content.innerHTML = ""; var t = function (t, e, n) { n && n.key && (t = n.key), n.values && (e = Object.values(n.values).indexOf(e)), o[t] = e }, e = LiteGraph.availableCanvasOptions; for (var n in e.sort(), e) { var i = e[n]; panel.addWidget("boolean", i, o[i], { key: i, on: "True", off: "False" }, t) } o.links_render_mode, panel.addWidget("combo", "Render mode", LiteGraph.LINK_RENDER_MODES[o.links_render_mode], { key: "links_render_mode", values: LiteGraph.LINK_RENDER_MODES }, t), panel.addSeparator(), panel.footer.innerHTML = "" } panel = o.createPanel("Options", { closable: !0, window: s, onOpen: function () { o.OPTIONPANEL_IS_OPEN = !0 }, onClose: function () { o.OPTIONPANEL_IS_OPEN = !1, o.options_panel = null } }), o.options_panel = panel, panel.id = "option-panel", panel.classList.add("settings"), r(), o.canvas.parentNode.appendChild(panel) }, LGraphCanvas.prototype.showShowNodePanel = function (t) { this.SELECTED_NODE = t, this.closePanels(); var e = this.getCanvasWindow(), n = this, i = this.createPanel(t.title || "", { closable: !0, window: e, onOpen: function () { n.NODEPANEL_IS_OPEN = !0 }, onClose: function () { n.NODEPANEL_IS_OPEN = !1, n.node_panel = null } }); function o() { i.content.innerHTML = "", i.addHTML("<span class='node_type'>" + t.type + "</span><span class='node_desc'>" + (t.constructor.desc || "") + "</span><span class='separator'></span>"), i.addHTML("<h3>Properties</h3>"); var e = function (e, i) { switch (n.graph.beforeChange(t), e) { case "Title": t.title = i; break; case "Mode": var o = Object.values(LiteGraph.NODE_MODES).indexOf(i); o >= 0 && LiteGraph.NODE_MODES[o] ? t.changeMode(o) : console.warn("unexpected mode: " + i); break; case "Color": LGraphCanvas.node_colors[i] ? (t.color = LGraphCanvas.node_colors[i].color, t.bgcolor = LGraphCanvas.node_colors[i].bgcolor) : console.warn("unexpected color: " + i); break; default: t.setProperty(e, i) }n.graph.afterChange(), n.dirty_canvas = !0 }; i.addWidget("string", "Title", t.title, {}, e), i.addWidget("combo", "Mode", LiteGraph.NODE_MODES[t.mode], { values: LiteGraph.NODE_MODES }, e); var o = ""; for (var s in void 0 !== t.color && (o = Object.keys(LGraphCanvas.node_colors).filter(function (e) { return LGraphCanvas.node_colors[e].color == t.color })), i.addWidget("combo", "Color", o, { values: Object.keys(LGraphCanvas.node_colors) }, e), t.properties) { var r = t.properties[s], a = t.getPropertyInfo(s); a.type, t.onAddPropertyToPanel && t.onAddPropertyToPanel(s, i) || i.addWidget(a.widget || a.type, s, r, a, e) } i.addSeparator(), t.onShowCustomPanelInfo && t.onShowCustomPanelInfo(i), i.footer.innerHTML = "", i.addButton("Delete", function () { t.block_delete || (t.graph.remove(t), i.close()) }).classList.add("delete") } n.node_panel = i, i.id = "node-panel", i.node = t, i.classList.add("settings"), i.inner_showCodePad = function (e) { i.classList.remove("settings"), i.classList.add("centered"), i.alt_content.innerHTML = "<textarea class='code'></textarea>"; var n = i.alt_content.querySelector("textarea"), s = function () { i.toggleAltContent(!1), i.toggleFooterVisibility(!0), n.parentNode.removeChild(n), i.classList.add("settings"), i.classList.remove("centered"), o() }; n.value = t.properties[e], n.addEventListener("keydown", function (i) { "Enter" == i.code && i.ctrlKey && (t.setProperty(e, n.value), s()) }), i.toggleAltContent(!0), i.toggleFooterVisibility(!1), n.style.height = "calc(100% - 40px)"; var r = i.addButton("Assign", function () { t.setProperty(e, n.value), s() }); i.alt_content.appendChild(r); var a = i.addButton("Close", s); a.style.float = "right", i.alt_content.appendChild(a) }, o(), this.canvas.parentNode.appendChild(i) }, LGraphCanvas.prototype.showSubgraphPropertiesDialog = function (t) { console.log("showing subgraph properties dialog"); var e = this.canvas.parentNode.querySelector(".subgraph_dialog"); e && e.close(); var n = this.createPanel("Subgraph Inputs", { closable: !0, width: 500 }); function i() { if (n.clear(), t.inputs) for (var e = 0; e < t.inputs.length; ++e) { var o = t.inputs[e]; if (!o.not_subgraph_input) { var s = "<button>&#10005;</button> <span class='bullet_icon'></span><span class='name'></span><span class='type'></span>", r = n.addHTML(s, "subgraph_property"); r.dataset.name = o.name, r.dataset.slot = e, r.querySelector(".name").innerText = o.name, r.querySelector(".type").innerText = o.type, r.querySelector("button").addEventListener("click", function (e) { t.removeInput(Number(this.parentNode.dataset.slot)), i() }) } } } n.node = t, n.classList.add("subgraph_dialog"); var o = " + <span class='label'>Name</span><input class='name'/><span class='label'>Type</span><input class='type'></input><button>+</button>"; return n.addHTML(o, "subgraph_property extra", !0).querySelector("button").addEventListener("click", function (e) { var n = this.parentNode, o = n.querySelector(".name").value, s = n.querySelector(".type").value; o && -1 == t.findInputSlot(o) && (t.addInput(o, s), n.querySelector(".name").value = "", n.querySelector(".type").value = "", i()) }), i(), this.canvas.parentNode.appendChild(n), n }, LGraphCanvas.prototype.showSubgraphPropertiesDialogRight = function (t) { var e = this.canvas.parentNode.querySelector(".subgraph_dialog"); e && e.close(); var n = this.createPanel("Subgraph Outputs", { closable: !0, width: 500 }); function i() { if (n.clear(), t.outputs) for (var e = 0; e < t.outputs.length; ++e) { var o = t.outputs[e]; if (!o.not_subgraph_output) { var s = "<button>&#10005;</button> <span class='bullet_icon'></span><span class='name'></span><span class='type'></span>", r = n.addHTML(s, "subgraph_property"); r.dataset.name = o.name, r.dataset.slot = e, r.querySelector(".name").innerText = o.name, r.querySelector(".type").innerText = o.type, r.querySelector("button").addEventListener("click", function (e) { t.removeOutput(Number(this.parentNode.dataset.slot)), i() }) } } } n.node = t, n.classList.add("subgraph_dialog"); var o = " + <span class='label'>Name</span><input class='name'/><span class='label'>Type</span><input class='type'></input><button>+</button>", s = n.addHTML(o, "subgraph_property extra", !0); function r() { var e = this.parentNode, n = e.querySelector(".name").value, o = e.querySelector(".type").value; n && -1 == t.findOutputSlot(n) && (t.addOutput(n, o), e.querySelector(".name").value = "", e.querySelector(".type").value = "", i()) } return s.querySelector(".name").addEventListener("keydown", function (t) { 13 == t.keyCode && r.apply(this) }), s.querySelector("button").addEventListener("click", function (t) { r.apply(this) }), i(), this.canvas.parentNode.appendChild(n), n }, LGraphCanvas.prototype.checkPanels = function () { if (this.canvas) for (var t = this.canvas.parentNode.querySelectorAll(".litegraph.dialog"), e = 0; e < t.length; ++e) { var n = t[e]; n.node && (!n.node.graph || n.graph != this.graph) && n.close() } }, LGraphCanvas.onMenuNodeCollapse = function (t, e, n, i, o) { o.graph.beforeChange(); var s = function (t) { t.collapse() }, r = LGraphCanvas.active_canvas; if (!r.selected_nodes || Object.keys(r.selected_nodes).length <= 1) s(o); else for (var a in r.selected_nodes) s(r.selected_nodes[a]); o.graph.afterChange() }, LGraphCanvas.onMenuNodePin = function (t, e, n, i, o) { o.pin() }, LGraphCanvas.onMenuNodeMode = function (t, e, n, i, o) { function s(t) { if (o) { var e = Object.values(LiteGraph.NODE_MODES).indexOf(t), n = function (n) { e >= 0 && LiteGraph.NODE_MODES[e] ? n.changeMode(e) : (console.warn("unexpected mode: " + t), n.changeMode(LiteGraph.ALWAYS)) }, i = LGraphCanvas.active_canvas; if (!i.selected_nodes || Object.keys(i.selected_nodes).length <= 1) n(o); else for (var s in i.selected_nodes) n(i.selected_nodes[s]) } } return new LiteGraph.ContextMenu(LiteGraph.NODE_MODES, { event: n, callback: s, parentMenu: i, node: o }), !1 }, LGraphCanvas.onMenuNodeColors = function (t, e, n, i, o) { if (!o) throw "no node for color"; var s = []; for (var r in s.push({ value: null, content: "<span style='display: block; padding-left: 4px;'>No color</span>" }), LGraphCanvas.node_colors) { var a = LGraphCanvas.node_colors[r], t = { value: r, content: "<span style='display: block; color: #999; padding-left: 4px; border-left: 8px solid " + a.color + "; background-color:" + a.bgcolor + "'>" + r + "</span>" }; s.push(t) } function l(t) { if (o) { var e = t.value ? LGraphCanvas.node_colors[t.value] : null, n = function (t) { e ? t.constructor === LiteGraph.LGraphGroup ? t.color = e.groupcolor : (t.color = e.color, t.bgcolor = e.bgcolor) : (delete t.color, delete t.bgcolor) }, i = LGraphCanvas.active_canvas; if (!i.selected_nodes || Object.keys(i.selected_nodes).length <= 1) n(o); else for (var s in i.selected_nodes) n(i.selected_nodes[s]); o.setDirtyCanvas(!0, !0) } } return new LiteGraph.ContextMenu(s, { event: n, callback: l, parentMenu: i, node: o }), !1 }, LGraphCanvas.onMenuNodeShapes = function (t, e, n, i, o) { if (!o) throw "no node passed"; function s(t) { if (o) { o.graph.beforeChange(); var e = function (e) { e.shape = t }, n = LGraphCanvas.active_canvas; if (!n.selected_nodes || Object.keys(n.selected_nodes).length <= 1) e(o); else for (var i in n.selected_nodes) e(n.selected_nodes[i]); o.graph.afterChange(), o.setDirtyCanvas(!0) } } return new LiteGraph.ContextMenu(LiteGraph.VALID_SHAPES, { event: n, callback: s, parentMenu: i, node: o }), !1 }, LGraphCanvas.onMenuNodeRemove = function (t, e, n, i, o) { if (!o) throw "no node passed"; var s = o.graph; s.beforeChange(); var r = function (t) { !1 !== t.removable && s.remove(t) }, a = LGraphCanvas.active_canvas; if (!a.selected_nodes || Object.keys(a.selected_nodes).length <= 1) r(o); else for (var l in a.selected_nodes) r(a.selected_nodes[l]); s.afterChange(), o.setDirtyCanvas(!0, !0) }, LGraphCanvas.onMenuNodeToSubgraph = function (t, e, n, i, o) { var s = o.graph, r = LGraphCanvas.active_canvas; if (r) { var a = Object.values(r.selected_nodes || {}); a.length || (a = [o]); var l = LiteGraph.createNode("graph/subgraph"); l.pos = o.pos.concat(), s.add(l), l.buildFromNodes(a), r.deselectAllNodes(), o.setDirtyCanvas(!0, !0) } }, LGraphCanvas.onMenuNodeClone = function (t, e, n, i, o) { o.graph.beforeChange(); var s = {}, r = function (t) { if (!1 !== t.clonable) { var e = t.clone(); e && (e.pos = [t.pos[0] + 5, t.pos[1] + 5], t.graph.add(e), s[e.id] = e) } }, a = LGraphCanvas.active_canvas; if (!a.selected_nodes || Object.keys(a.selected_nodes).length <= 1) r(o); else for (var l in a.selected_nodes) r(a.selected_nodes[l]); Object.keys(s).length && a.selectNodes(s), o.graph.afterChange(), o.setDirtyCanvas(!0, !0) }, LGraphCanvas.node_colors = { red: { color: "#322", bgcolor: "#533", groupcolor: "#A88" }, brown: { color: "#332922", bgcolor: "#593930", groupcolor: "#b06634" }, green: { color: "#232", bgcolor: "#353", groupcolor: "#8A8" }, blue: { color: "#223", bgcolor: "#335", groupcolor: "#88A" }, pale_blue: { color: "#2a363b", bgcolor: "#3f5159", groupcolor: "#3f789e" }, cyan: { color: "#233", bgcolor: "#355", groupcolor: "#8AA" }, purple: { color: "#323", bgcolor: "#535", groupcolor: "#a1309b" }, yellow: { color: "#432", bgcolor: "#653", groupcolor: "#b58b2a" }, black: { color: "#222", bgcolor: "#000", groupcolor: "#444" } }, LGraphCanvas.prototype.getCanvasMenuOptions = function () { var t = null; if (this.getMenuOptions ? t = this.getMenuOptions() : (t = [{ content: "Add Node", has_submenu: !0, callback: LGraphCanvas.onMenuAdd }, { content: "Add Group", callback: LGraphCanvas.onGroupAdd }], Object.keys(this.selected_nodes).length > 1 && t.push({ content: "Align", has_submenu: !0, callback: LGraphCanvas.onGroupAlign }), this._graph_stack && this._graph_stack.length > 0 && t.push(null, { content: "Close subgraph", callback: this.closeSubgraph.bind(this) })), this.getExtraMenuOptions) { var e = this.getExtraMenuOptions(this, t); e && (t = t.concat(e)) } return t }, LGraphCanvas.prototype.getNodeMenuOptions = function (t) { var e = null; if (t.getMenuOptions ? e = t.getMenuOptions(this) : (e = [{ content: "Inputs", has_submenu: !0, disabled: !0, callback: LGraphCanvas.showMenuNodeOptionalInputs }, { content: "Outputs", has_submenu: !0, disabled: !0, callback: LGraphCanvas.showMenuNodeOptionalOutputs }, null, { content: "Properties", has_submenu: !0, callback: LGraphCanvas.onShowMenuNodeProperties }, null, { content: "Title", callback: LGraphCanvas.onShowPropertyEditor }, { content: "Mode", has_submenu: !0, callback: LGraphCanvas.onMenuNodeMode }], !1 !== t.resizable && e.push({ content: "Resize", callback: LGraphCanvas.onMenuResizeNode }), e.push({ content: "Collapse", callback: LGraphCanvas.onMenuNodeCollapse }, { content: "Pin", callback: LGraphCanvas.onMenuNodePin }, { content: "Colors", has_submenu: !0, callback: LGraphCanvas.onMenuNodeColors }, { content: "Shapes", has_submenu: !0, callback: LGraphCanvas.onMenuNodeShapes }, null)), t.onGetInputs) { var n = t.onGetInputs(); n && n.length && (e[0].disabled = !1) } if (t.onGetOutputs) { var i = t.onGetOutputs(); i && i.length && (e[1].disabled = !1) } if (t.getExtraMenuOptions) { var o = t.getExtraMenuOptions(this, e); o && (o.push(null), e = o.concat(e)) } return !1 !== t.clonable && e.push({ content: "Clone", callback: LGraphCanvas.onMenuNodeClone }), Object.keys(this.selected_nodes).length > 1 && e.push({ content: "Align Selected To", has_submenu: !0, callback: LGraphCanvas.onNodeAlign }), e.push(null, { content: "Remove", disabled: !(!1 !== t.removable && !t.block_delete), callback: LGraphCanvas.onMenuNodeRemove }), t.graph && t.graph.onGetNodeMenuOptions && t.graph.onGetNodeMenuOptions(e, t), e }, LGraphCanvas.prototype.getGroupMenuOptions = function (t) { return [{ content: "Title", callback: LGraphCanvas.onShowPropertyEditor }, { content: "Color", has_submenu: !0, callback: LGraphCanvas.onMenuNodeColors }, { content: "Font size", property: "font_size", type: "Number", callback: LGraphCanvas.onShowPropertyEditor }, null, { content: "Remove", callback: LGraphCanvas.onMenuNodeRemove }] }, LGraphCanvas.prototype.processContextMenu = function (t, e) { var n = this, i = LGraphCanvas.active_canvas.getCanvasWindow(), o = null, s = { event: e, callback: h, extra: t }; t && (s.title = t.type); var r = null; if (t && (r = t.getSlotInPosition(e.canvasX, e.canvasY), LGraphCanvas.active_node = t), r) { if (o = [], t.getSlotMenuOptions) o = t.getSlotMenuOptions(r); else { r && r.output && r.output.links && r.output.links.length && o.push({ content: "Disconnect Links", slot: r }); var a = r.input || r.output; a.removable && o.push(a.locked ? "Cannot remove" : { content: "Remove Slot", slot: r }), a.nameLocked || o.push({ content: "Rename Slot", slot: r }) } s.title = (r.input ? r.input.type : r.output.type) || "*", r.input && r.input.type == LiteGraph.ACTION && (s.title = "Action"), r.output && r.output.type == LiteGraph.EVENT && (s.title = "Event") } else if (t) o = this.getNodeMenuOptions(t); else { o = this.getCanvasMenuOptions(); var l = this.graph.getGroupOnPos(e.canvasX, e.canvasY); l && o.push(null, { content: "Edit Group", has_submenu: !0, submenu: { title: "Group", extra: l, options: this.getGroupMenuOptions(l) } }) } function h(e, i, o) { if (e) { if ("Remove Slot" == e.content) { var s = e.slot; t.graph.beforeChange(), s.input ? t.removeInput(s.slot) : s.output && t.removeOutput(s.slot), t.graph.afterChange(); return } if ("Disconnect Links" == e.content) { var s = e.slot; t.graph.beforeChange(), s.output ? t.disconnectOutput(s.slot) : s.input && t.disconnectInput(s.slot), t.graph.afterChange(); return } if ("Rename Slot" == e.content) { var s = e.slot, r = s.input ? t.getInputInfo(s.slot) : t.getOutputInfo(s.slot), a = n.createDialog("<span class='name'>Name</span><input autofocus type='text'/><button>OK</button>", i), l = a.querySelector("input"); l && r && (l.value = r.label || ""); var h = function () { t.graph.beforeChange(), l.value && (r && (r.label = l.value), n.setDirty(!0)), a.close(), t.graph.afterChange() }; a.querySelector("button").addEventListener("click", h), l.addEventListener("keydown", function (t) { if (a.is_modified = !0, 27 == t.keyCode) a.close(); else if (13 == t.keyCode) h(); else if (13 != t.keyCode && "textarea" != t.target.localName) return; t.preventDefault(), t.stopPropagation() }), l.focus() } } } o && new LiteGraph.ContextMenu(o, s, i) }, LiteGraph.compareObjects = compareObjects, LiteGraph.distance = distance, LiteGraph.colorToString = colorToString, LiteGraph.isInsideRectangle = isInsideRectangle, LiteGraph.growBounding = growBounding, LiteGraph.isInsideBounding = isInsideBounding, LiteGraph.overlapBounding = overlapBounding, LiteGraph.hex2num = hex2num, LiteGraph.num2hex = num2hex, ContextMenu.prototype.addItem = function (t, e, n) { var i = this; n = n || {}; var o = document.createElement("div"); o.className = "litemenu-entry submenu"; var s = !1; function r(t) { var e = this.value; e && e.has_submenu && a.call(this, t) } function a(t) { var e = this.value, o = !0; if (i.current_submenu && i.current_submenu.close(t), n.callback) { var s = n.callback.call(this, e, n, t, i, n.node); !0 === s && (o = !1) } if (e) { if (e.callback && !n.ignore_item_callbacks && !0 !== e.disabled) { var s = e.callback.call(this, e, n, t, i, n.extra); !0 === s && (o = !1) } if (e.submenu) { if (!e.submenu.options) throw "ContextMenu submenu needs options"; new i.constructor(e.submenu.options, { callback: e.submenu.callback, event: t, parentMenu: i, ignore_item_callbacks: e.submenu.ignore_item_callbacks, title: e.submenu.title, extra: e.submenu.extra, autoopen: n.autoopen }), o = !1 } } o && !i.lock && i.close() } return null === e ? o.classList.add("separator") : (o.innerHTML = e && e.title ? e.title : t, o.value = e, e && (e.disabled && (s = !0, o.classList.add("disabled")), (e.submenu || e.has_submenu) && o.classList.add("has_submenu")), "function" == typeof e ? (o.dataset.value = t, o.onclick_callback = e) : o.dataset.value = e, e.className && (o.className += " " + e.className)), this.root.appendChild(o), s || o.addEventListener("click", a), !s && n.autoopen && LiteGraph.pointerListenerAdd(o, "enter", r), o }, ContextMenu.prototype.close = function (t, e) { this.root.parentNode && this.root.parentNode.removeChild(this.root), this.parentMenu && !e && (this.parentMenu.lock = !1, this.parentMenu.current_submenu = null, void 0 === t ? this.parentMenu.close() : t && !ContextMenu.isCursorOverElement(t, this.parentMenu.root) && ContextMenu.trigger(this.parentMenu.root, LiteGraph.pointerevents_method + "leave", t)), this.current_submenu && this.current_submenu.close(t, !0), this.root.closing_timer && clearTimeout(this.root.closing_timer) }, ContextMenu.trigger = function (t, e, n, i) { var o = document.createEvent("CustomEvent"); return o.initCustomEvent(e, !0, !0, n), o.srcElement = i, t.dispatchEvent ? t.dispatchEvent(o) : t.__events && t.__events.dispatchEvent(o), o }, ContextMenu.prototype.getTopMenu = function () { return this.options.parentMenu ? this.options.parentMenu.getTopMenu() : this }, ContextMenu.prototype.getFirstEvent = function () { return this.options.parentMenu ? this.options.parentMenu.getFirstEvent() : this.options.event }, ContextMenu.isCursorOverElement = function (t, e) { var n = t.clientX, i = t.clientY, o = e.getBoundingClientRect(); return !!o && !!(i > o.top) && !!(i < o.top + o.height) && !!(n > o.left) && !!(n < o.left + o.width) }, LiteGraph.ContextMenu = ContextMenu, LiteGraph.closeAllContextMenus = function (t) { var e = (t = t || window).document.querySelectorAll(".litecontextmenu"); if (e.length) { for (var n = [], i = 0; i < e.length; i++)n.push(e[i]); for (var i = 0; i < n.length; i++)n[i].close ? n[i].close() : n[i].parentNode && n[i].parentNode.removeChild(n[i]) } }, LiteGraph.extendClass = function (t, e) { for (var n in e) !t.hasOwnProperty(n) && (t[n] = e[n]); if (e.prototype) for (var n in e.prototype) !(!e.prototype.hasOwnProperty(n) || t.prototype.hasOwnProperty(n)) && (e.prototype.__lookupGetter__(n) ? t.prototype.__defineGetter__(n, e.prototype.__lookupGetter__(n)) : t.prototype[n] = e.prototype[n], e.prototype.__lookupSetter__(n) && t.prototype.__defineSetter__(n, e.prototype.__lookupSetter__(n))) }, CurveEditor.sampleCurve = function (t, e) { if (e) { for (var n = 0; n < e.length - 1; ++n) { var i = e[n], o = e[n + 1]; if (!(o[0] < t)) { var s = o[0] - i[0]; if (1e-5 > Math.abs(s)) return i[1]; var r = (t - i[0]) / s; return i[1] * (1 - r) + o[1] * r } } return 0 } }, CurveEditor.prototype.draw = function (t, e, n, i, o, s) { var r = this.points; if (r) { this.size = e; var a = e[0] - 2 * this.margin, l = e[1] - 2 * this.margin; o = o || "#666", t.save(), t.translate(this.margin, this.margin), i && (t.fillStyle = "#111", t.fillRect(0, 0, a, l), t.fillStyle = "#222", t.fillRect(.5 * a, 0, 1, l), t.strokeStyle = "#333", t.strokeRect(0, 0, a, l)), t.strokeStyle = o, s && (t.globalAlpha = .5), t.beginPath(); for (var h = 0; h < r.length; ++h) { var u = r[h]; t.lineTo(u[0] * a, (1 - u[1]) * l) } if (t.stroke(), t.globalAlpha = 1, !s) for (var h = 0; h < r.length; ++h) { var u = r[h]; t.fillStyle = this.selected == h ? "#FFF" : this.nearest == h ? "#DDD" : "#AAA", t.beginPath(), t.arc(u[0] * a, (1 - u[1]) * l, 2, 0, 2 * Math.PI), t.fill() } t.restore() } }, CurveEditor.prototype.onMouseDown = function (t, e) { var n = this.points; if (n && !(t[1] < 0)) { var i = this.size[0] - 2 * this.margin, o = this.size[1] - 2 * this.margin, s = t[0] - this.margin, r = t[1] - this.margin, a = [s, r], l = 30 / e.ds.scale; if (this.selected = this.getCloserPoint(a, l), -1 == this.selected) { var h = [s / i, 1 - r / o]; n.push(h), n.sort(function (t, e) { return t[0] - e[0] }), this.selected = n.indexOf(h), this.must_update = !0 } if (-1 != this.selected) return !0 } }, CurveEditor.prototype.onMouseMove = function (t, e) { var n = this.points; if (n) { var i = this.selected; if (!(i < 0)) { var o = (t[0] - this.margin) / (this.size[0] - 2 * this.margin), s = (t[1] - this.margin) / (this.size[1] - 2 * this.margin), r = [t[0] - this.margin, t[1] - this.margin], a = 30 / e.ds.scale; this._nearest = this.getCloserPoint(r, a); var l = n[i]; if (l) { var h = 0 == i || i == n.length - 1; if (!h && (t[0] < -10 || t[0] > this.size[0] + 10 || t[1] < -10 || t[1] > this.size[1] + 10)) { n.splice(i, 1), this.selected = -1; return } h ? l[0] = 0 == i ? 0 : 1 : l[0] = clamp(o, 0, 1), l[1] = 1 - clamp(s, 0, 1), n.sort(function (t, e) { return t[0] - e[0] }), this.selected = n.indexOf(l), this.must_update = !0 } } } }, CurveEditor.prototype.onMouseUp = function (t, e) { return this.selected = -1, !1 }, CurveEditor.prototype.getCloserPoint = function (t, e) { var n = this.points; if (!n) return -1; e = e || 30; for (var i = this.size[0] - 2 * this.margin, o = this.size[1] - 2 * this.margin, s = n.length, r = [0, 0], a = 1e6, l = -1, h = -1, u = 0; u < s; ++u) { var p = n[u]; r[0] = p[0] * i, r[1] = (1 - p[1]) * o, r[0] < t[0] && (h = u); var c = vec2.distance(t, r); c > a || c > e || (l = u, a = c) } return l }, LiteGraph.CurveEditor = CurveEditor, LiteGraph.getParameterNames = function (t) { return (t + "").replace(/[/][/].*$/gm, "").replace(/\s+/g, "").replace(/[/][*][^/*]*[*][/]/g, "").split("){", 1)[0].replace(/^[^(]*[(]/, "").replace(/=[^,]+/g, "").split(",").filter(Boolean) }, LiteGraph.pointerListenerAdd = function (t, e, n, i = !1) { if (t && t.addEventListener && e && "function" == typeof n) { var o = LiteGraph.pointerevents_method, s = e; if ("pointer" == o && !window.PointerEvent) switch (console.warn("sMethod=='pointer' && !window.PointerEvent"), console.log("Converting pointer[" + s + "] : down move up cancel enter TO touchstart touchmove touchend, etc .."), s) { case "down": o = "touch", s = "start"; break; case "move": case "cancel": o = "touch"; break; case "up": o = "touch", s = "end"; break; case "enter": console.log("debug: Should I send a move event?"); break; default: console.warn("PointerEvent not available in this browser ? The event " + s + " would not be called") }switch (s) { case "down": case "up": case "move": case "over": case "out": case "enter": t.addEventListener(o + s, n, i); case "leave": case "cancel": case "gotpointercapture": case "lostpointercapture": if ("mouse" != o) return t.addEventListener(o + s, n, i); default: return t.addEventListener(s, n, i) } } }, LiteGraph.pointerListenerRemove = function (t, e, n, i = !1) { if (t && t.removeEventListener && e && "function" == typeof n) switch (e) { case "down": case "up": case "move": case "over": case "out": case "enter": ("pointer" == LiteGraph.pointerevents_method || "mouse" == LiteGraph.pointerevents_method) && t.removeEventListener(LiteGraph.pointerevents_method + e, n, i); case "leave": case "cancel": case "gotpointercapture": case "lostpointercapture": if ("pointer" == LiteGraph.pointerevents_method) return t.removeEventListener(LiteGraph.pointerevents_method + e, n, i); default: return t.removeEventListener(e, n, i) } }, global.clamp = clamp, "undefined" == typeof window || window.requestAnimationFrame || (window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (t) { window.setTimeout(t, 1e3 / 60) }) }(this), "undefined" != typeof exports && (exports.LiteGraph = this.LiteGraph, exports.LGraph = this.LGraph, exports.LLink = this.LLink, exports.LGraphNode = this.LGraphNode, exports.LGraphGroup = this.LGraphGroup, exports.DragAndScale = this.DragAndScale, exports.LGraphCanvas = this.LGraphCanvas, exports.ContextMenu = this.ContextMenu);